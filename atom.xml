<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ritchie&#39;s Blog</title>
  
  
  <link href="https://ritchielambda.github.io/atom.xml" rel="self"/>
  
  <link href="https://ritchielambda.github.io/"/>
  <updated>2025-02-20T14:21:17.240Z</updated>
  <id>https://ritchielambda.github.io/</id>
  
  <author>
    <name>Ritchie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UE Animation</title>
    <link href="https://ritchielambda.github.io/2025/01/23/UEAnimation/"/>
    <id>https://ritchielambda.github.io/2025/01/23/UEAnimation/</id>
    <published>2025-01-23T09:09:53.000Z</published>
    <updated>2025-02-20T14:21:17.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE-Animation"><a href="#UE-Animation" class="headerlink" title="UE Animation"></a>UE Animation</h1><p>​    Evaluate的Transform结果存在了Meshcomponent中然后在meshobject的UpdateDynamicData_RenderThread的UpdateRefToLocalMatrices被传给了Referencetolocal，最后传给了VF的buffer，VF是存在MeshObject中的，也是构造的时候meshcomponent的时候的renderdata赋值的。</p><p>SceneProxy里的MeshObject是copy Component里的，渲染的时候getdynamicelements直接拿数据。</p><p>如果是CPUSkin，也是在Update里做蒙皮，CacheVerticles，Evaluate的结果也是存在ReferenceToLocal，SkinVertexSection中直接对LOD的顶点数据进行权重矩阵运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UE-Animation&quot;&gt;&lt;a href=&quot;#UE-Animation&quot; class=&quot;headerlink&quot; title=&quot;UE Animation&quot;&gt;&lt;/a&gt;UE Animation&lt;/h1&gt;&lt;p&gt;​    Evaluate的Transform结果存在了Me</summary>
      
    
    
    
    
    <category term="UE源码" scheme="https://ritchielambda.github.io/tags/UE%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ParticleSystem</title>
    <link href="https://ritchielambda.github.io/2024/12/06/ParticleSystem/"/>
    <id>https://ritchielambda.github.io/2024/12/06/ParticleSystem/</id>
    <published>2024-12-06T21:49:00.000Z</published>
    <updated>2025-02-20T14:21:17.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UEParticleSystem"><a href="#UEParticleSystem" class="headerlink" title="UEParticleSystem"></a>UEParticleSystem</h1><p>UE4的粒子系统核心成员就是ParticleSystemComponent。特效同学在编辑器下编辑粒子特效生成模板数据，程序在运行时根据模板生成对应的Component，然后在Tick中更新粒子效果直至生命周期结束。本篇暂不涉及编辑器下粒子的数据编辑与生成，只讨论运行时的粒子更新流程。</p><span id="more"></span><h2 id="ParticleSystemComponent"><a href="#ParticleSystemComponent" class="headerlink" title="ParticleSystemComponent"></a>ParticleSystemComponent</h2><p><img src="/2024/12/06/ParticleSystem/ParticleComponent.png" alt="ParticleComponent"></p><p>可以看到Particle主要分成三个部分，UParticleSystem，FParticleEmitterInstance，SceneProxy，这三个分别是粒子模板数据，运行时的粒子实例数据，以及渲染线程与Component一一对应的渲染数据。</p><p>一个完整的粒子特效通常需要多个发射器来组成，比如火焰特效需要火苗以及烟雾发射器。而每个发射区又区分多个Module，负责粒子的各种表现，如SpawnModule负责生成，LocationModule负责位置数据更新，需要注意的是，在Emitter和Module之间，还存在一个LODLevel管理，以便粒子特效的性能优化。</p><h2 id="一个粒子的更新流程"><a href="#一个粒子的更新流程" class="headerlink" title="一个粒子的更新流程"></a>一个粒子的更新流程</h2><p>CPU端主要的计算是在ParticleSystemComponent的ComputeTickComponent_Concurrent中调用的，整个更新的调用链如下：</p><p>可以看到这里跟编辑器中重合的部分就是各个Module的Update，在上面的结构图里讨论过，Instance和Module之间存在一个LODLevel，这里同样在UpdateModule中是根据LODLevel中的Module来实时更新的。</p><p>GPU端的更新分为两步：一是每帧结束时填充Proxy数据，二是渲染流程中获取Mesh数据。</p><p><img src="/2024/12/06/ParticleSystem/PrivateBlog\source\_posts\ParticleSystem\particlecall.jpg" alt="particlecall"></p><p>需要注意TypeDataModule，这个Module比较特殊，它决定了粒子Emitter的类型，这里有几种不同类型的粒子发射器以满足不同需求，与发射器类型对应的就是渲染数据的不同，FDynamicEmitterDataBase，在获取渲染数据时也会根据类型不同调用不同子类接口。</p><p><img src="/2024/12/06/ParticleSystem/CreateInstance.md" alt="image-20241206185935331"></p><p><img src="/2024/12/06/ParticleSystem/EmitterInstanceType.png" alt="image-20241213181447276"></p><h1 id="NiagaraSystem"><a href="#NiagaraSystem" class="headerlink" title="NiagaraSystem"></a>NiagaraSystem</h1><p>这个系统可以说是UE4 ParticleSystem的升级版，可以更加自由地组合粒子发射器，对粒子系统编程。与之前Cascade系统的差别主要如下：</p><ul><li>Emitter独立于Component之外，可以自由组合。</li><li>丢弃LODLevel层。</li><li>每个Emitter可以根据阶段添加Module，进行调参。</li></ul><h2 id="NiagaraComponent"><a href="#NiagaraComponent" class="headerlink" title="NiagaraComponent"></a>NiagaraComponent</h2><p><img src="/2024/12/06/ParticleSystem/NiagaraComponent.drawio.png" alt="NiagaraComponent.drawio"></p><p>储存粒子数据的结构是FNiagaraDataSet，两个DataBuffer成员分别是当前帧的输入和输出数据。</p><p>在SceneProxy端根据Emitter类型的不同，放入不同的Render中存储渲染，存储的粒子数据位于FNiagaraDynamicDataBase，里面存储了CPU和GPU端的粒子渲染数据。</p><h2 id="粒子的更新流程"><a href="#粒子的更新流程" class="headerlink" title="粒子的更新流程"></a>粒子的更新流程</h2><p><img src="/2024/12/06/ParticleSystem/NiagaraUpdate.drawio.png" alt="NiagaraUpdate.drawio"></p><p>粒子的更新还是在Tick中完成的，与Cascade系统不同的是，这里不会再显式地调用每个Module的更新。</p><p>更新阶段区分CPU还是GPU粒子，CPU端的粒子最终是通过虚拟机执行脚本来更新，可以看到先执行SpawnContext然后执行UpdateContext，而GPU端粒子则只负责把数据放入FNiagaraSystemGpuComputeProxy的PendingTicks队列，之后会在渲染线程获取队列数据，然后把队列数据转为Dispatch数据，最终把数据传入ComputeShader进行更新。更新的数据buff始终是EmitterInstance中的DataBuffer。</p><p>GPU端粒子更新区分为三个阶段，如何决定是哪个阶段是在FNiagaraSystemGpuComputeProxy中，最简单的如果需要深度或者距离场信息，那么就需要放到不透明后再更新，默认是在PreInitView阶段。</p><p><img src="/2024/12/06/ParticleSystem/TickStage.png" alt="image-20241220175929596"></p><h2 id="粒子的渲染"><a href="#粒子的渲染" class="headerlink" title="粒子的渲染"></a>粒子的渲染</h2><p>由于渲染流程基本没什么变化，所以还是走Component数据转移到SceneProxy，然后数据生成MeshBatch，最后生成MeshDrawCommands这一套。</p><p><img src="/2024/12/06/ParticleSystem/NiagraRender.drawio.png" alt="NiagraRender.drawio"></p><p>首先先把之前更新的数据转移到Render线程下管理，然后再借助这些数据生成MeshBatch。</p><p><img src="/2024/12/06/ParticleSystem/NiagaraMeshBatch.drawio.png" alt="NiagaraMeshBatch.drawio"></p><p>生成MeshBatch的流程入口还是在GetDynamicMeshElements，一步步调用到Renderer的接口，根据粒子类型不同调用不同renderer，需要注意的是这里传输粒子顶点数据有两个重要的Buffer，FNiagaraSpriteUniformParameters和FNiagaraSpriteVFLooseParameters。</p><p>FNiagaraSpriteUniformParameters是与View相关的Buffer，包含粒子渲染的一些基础参数，比如默认位置，颜色，以及实例数据的布局等</p><p>FNiagaraSpriteVFLooseParameters是与实例相关的Buffer，存储了之前更新粒子的每个实例数据。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;UEParticleSystem&quot;&gt;&lt;a href=&quot;#UEParticleSystem&quot; class=&quot;headerlink&quot; title=&quot;UEParticleSystem&quot;&gt;&lt;/a&gt;UEParticleSystem&lt;/h1&gt;&lt;p&gt;UE4的粒子系统核心成员就是ParticleSystemComponent。特效同学在编辑器下编辑粒子特效生成模板数据，程序在运行时根据模板生成对应的Component，然后在Tick中更新粒子效果直至生命周期结束。本篇暂不涉及编辑器下粒子的数据编辑与生成，只讨论运行时的粒子更新流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图形学" scheme="https://ritchielambda.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HISM</title>
    <link href="https://ritchielambda.github.io/2024/07/28/HISM/"/>
    <id>https://ritchielambda.github.io/2024/07/28/HISM/</id>
    <published>2024-07-28T22:04:53.000Z</published>
    <updated>2025-02-20T14:21:17.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HierarchicalInstancedStaticMeshComponent"><a href="#HierarchicalInstancedStaticMeshComponent" class="headerlink" title="HierarchicalInstancedStaticMeshComponent"></a>HierarchicalInstancedStaticMeshComponent</h1><p>​    InstancedStaticMesh是UE针对使用相同Material，但是具有不同transform的物体的优化方案，可以将这些物体在创建时静态合批，大量减少drawcall，而InstancedStaticMesh(后续简称ISM)存在以下缺点：</p><ol><li>所有的ISM都使用相同的LOD，导致远处的ISM也会被赋予高级别LOD，造成浪费。</li><li>一组ISM共享剔除，只要有一个ISM实例被绘制，那么这一组都会被绘制，剔除同理，也会造成浪费。</li></ol><p>​    因此又衍生出了HISM，可以针对一组ISM生成对应的N叉树，便于空间管理，在生成meshbatch的时候根据可见性剔除不必要的子节点，避免造成浪费。</p><span id="more"></span><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HISM中有两个关键成员，用来保存每个Instance Transform的PerInstanceSMData，用来空间管理Instance的ClusterTreePtr。</p><h2 id="HISM-空间管理"><a href="#HISM-空间管理" class="headerlink" title="HISM 空间管理"></a>HISM 空间管理</h2><p>​    通常我们一般用八叉树来进行空间管理，这样既直观，而且算法上也便于理解，如下图：<img src="/2024/07/28/HISM/eightbranchtree.png" alt="空间八叉树" style="zoom: 50%;"></p><p>​    然而HISM采用N叉树来进行空间划分，这样的好处是空间划分更加灵活，剔除更加高效，缺点是不那么直观。下面我们看下HISM是如何构建N叉树的：</p><h3 id="N叉树构建"><a href="#N叉树构建" class="headerlink" title="N叉树构建"></a>N叉树构建</h3><p>​    HISM的构建入口在BuildTree，借助了FClusterBuilder类来实现真正的构建，构建大体分为以下几步：</p><ol><li>初始化Builder以及N叉树的预设值。</li><li>构建底层叶子节点。</li><li>搭建N叉树结构。</li></ol><h4 id="1-初始化构建参数"><a href="#1-初始化构建参数" class="headerlink" title="1. 初始化构建参数"></a>1. 初始化构建参数</h4><p>​    MaxInstancesPerLeaf：N叉树每个叶子节点最多包含的Instance个数，初始化值为8192/该Mesh LOD0下的顶点数，所以Mesh越复杂，MaxInstancesPerLeaf越小，叶子节点划分越细。</p><p>​    InternalNodeBranchingFactor：N叉树叶子的分支系数，默认是16，每个节点最多有多少个子节点</p><h4 id="2-构建子节点"><a href="#2-构建子节点" class="headerlink" title="2.构建子节点"></a>2.构建子节点</h4><p>​    对所有的Instance进行递归二分，二分规则是根据所有节点的坐标，对当前范围所有节点所形成的包围盒的长轴进行二分，然后不断递归，直至当前二分Instance的个数小于BranchingFactor结束。<br>​    如下图所示，在一个立方体内随机生成50个Instance，每次二分会根据当前所在空间最长轴将Instanec进行划分，直到当前空间内包含的Instance个数小于BranchingFactor，最终生成M个包含若干个Instance的ClusterNode，可以看出每个ClusterNode所分配的空间与空间内包含Instance的密度有关。</p><p>举例：如果有50个Instance，那么根据节点所在空间密度，划分为以下几个子节点：<br>    [0,10] [11,25] [26,35] [36,40] [41,50]</p><p>这些节点会作为N叉树构建的叶子节点</p><p><img src="/2024/07/28/HISM/Nbranchtree.png" alt="HISM的空间不断划分"></p><ol><li><h4 id="构建树结构"><a href="#构建树结构" class="headerlink" title="构建树结构"></a>构建树结构</h4></li></ol><p>​        根据第二步得到的叶子节点，再进行split递归算法，每一次split，都会向上生成一层父节点，直到生成根节点为止，而split的算法本质上就是进行递归归化，不断的将一个空间内的节点按照空间位置进行划分，合并成新的节点。</p><p><img src="/2024/07/28/HISM/Ntree.png" alt="构建N叉树"></p><p>需要注意的是，每个HISM实例是按照顺序PerInstanceSMData数组中，但是排序下标不会按照空间划分好的顺序，上图中可以看出每个节点包含的实例index都是连续的切从大到小的，这是由split算法决定的，且在构建树结构的过程中，需要不断更新索引值，但是不会修改PerInstanceSMData原有数据的位置，最终Builder会输出SortedInstances来重定向tree中实例的index-&gt;数组中真正的下标index。</p><p>在下面接口的调用中可以看出用了remapping</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GatherInstanceTransformsInArea</span><span class="params">(<span class="type">const</span> UHierarchicalInstancedStaticMeshComponent&amp; Component, <span class="type">const</span> FBox&amp; AreaBox, int32 Child, TArray&lt;FTransform&gt;&amp; InstanceData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> TArray&lt;FClusterNode&gt;&amp; ClusterTree = *Component.ClusterTreePtr;</span><br><span class="line">    <span class="keyword">if</span> (ClusterTree.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> FClusterNode&amp; ChildNode = ClusterTree[Child];</span><br><span class="line">       <span class="type">const</span> FBox WorldNodeBox = <span class="built_in">FBox</span>(ChildNode.BoundMin, ChildNode.BoundMax).<span class="built_in">TransformBy</span>(Component.<span class="built_in">GetComponentTransform</span>());</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (AreaBox.<span class="built_in">Intersect</span>(WorldNodeBox))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (ChildNode.FirstChild &lt; <span class="number">0</span> || AreaBox.<span class="built_in">IsInside</span>(WorldNodeBox))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">// Unfortunately ordering of PerInstanceSMData does not match ordering of cluster tree, so we have to use remaping</span></span><br><span class="line">             <span class="comment">//重定向到数组中的index</span></span><br><span class="line">              <span class="type">const</span> <span class="type">bool</span> bUseRemaping = Component.SortedInstances.<span class="built_in">Num</span>() &gt; <span class="number">0</span>;</span><br><span class="line">          </span><br><span class="line">             <span class="comment">// In case there no more subdivision or node is completely encapsulated by a area box</span></span><br><span class="line">             <span class="comment">// add all instances to the result</span></span><br><span class="line">             <span class="keyword">for</span> (int32 i = ChildNode.FirstInstance; i &lt;= ChildNode.LastInstance; ++i)</span><br><span class="line">             &#123;</span><br><span class="line">                int32 SortedIdx = bUseRemaping ? Component.SortedInstances[i] : i;</span><br><span class="line">             &#125;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终Builder输出了一个FClusterTree结构体，并赋值给HISM对应的成员。</p><p>N叉树构建好了，接下来就是如何根据空间结构进行裁剪，然后进行合批。</p><h3 id="可见性剔除"><a href="#可见性剔除" class="headerlink" title="可见性剔除"></a>可见性剔除</h3><p>之前在渲染工作流的可见性篇中有提到所有动态相关性的物体生成Meshbatch都是通过GetDynamicMeshElements接口来的，HISM也不例外，而空间剔除就发生在这个时候，函数入口是FHierarchicalStaticMeshSceneProxy::Traverse，该算法主要是递归HISM的ClusterTree，如果父节点没有和视锥相交，那么子节点也同样不会相交，这样即可停止递归，如果该节点可见，那么需要判断节点的LOD是否不满足要求（是否满足最模糊LOD绘制，LOD0为最清晰，所以LOD越大，越模糊），通过CalcLOD，可以计算出当前节点绘制的LOD（原理是通过节点在屏幕上的绘制大小，得到绘制距离，与StaticMesh的LOD距离对比，得到匹配的LOD级数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FHierarchicalStaticMeshSceneProxy::Traverse</span><span class="params">(<span class="type">const</span> FFoliageCullInstanceParams&amp; Params, int32 Index, int32 MinLOD, int32 MaxLOD, <span class="type">bool</span> bFullyContained)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FClusterNode&amp; Node = Params.Tree[Index];</span><br><span class="line">    <span class="comment">//该节点不相交，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (!bFullyContained)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">CullNode</span>&lt;TUseVector&gt;(Params, Node, bFullyContained))</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断LOD是否满足要求</span></span><br><span class="line">    <span class="keyword">if</span> (MinLOD != MaxLOD)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">CalcLOD</span>(MinLOD, MaxLOD, Node.BoundMin, Node.BoundMax, Params.ViewOriginInLocalZero, Params.ViewOriginInLocalOne, Params.LODPlanesMin, Params.LODPlanesMax);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (MinLOD &gt;= Params.LODs)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Index &gt;= Params.FirstOcclusionNode &amp;&amp; Index &lt;= Params.LastOcclusionNode)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">check</span>(Params.OcclusionResults != <span class="literal">NULL</span>);</span><br><span class="line">       <span class="type">const</span> TArray&lt;<span class="type">bool</span>&gt;&amp; OcclusionResultsArray = *Params.OcclusionResults;</span><br><span class="line">       <span class="keyword">if</span> (OcclusionResultsArray[Params.OcclusionResultsStart + Index - Params.FirstOcclusionNode])</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">INC_DWORD_STAT_BY</span>(STAT_OcclusionCulledFoliageInstances, <span class="number">1</span> + Node.LastInstance - Node.FirstInstance);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bShouldGroup = Node.FirstChild &lt; <span class="number">0</span></span><br><span class="line">       || ((Node.LastInstance - Node.FirstInstance + <span class="number">1</span>) &lt; Params.MinInstancesToSplit[MinLOD]</span><br><span class="line">          &amp;&amp; <span class="built_in">CanGroup</span>(Node.BoundMin, Node.BoundMax, Params.ViewOriginInLocalZero, Params.ViewOriginInLocalOne, Params.LODPlanesMax[Params.LODs - <span class="number">1</span>]));</span><br><span class="line">    <span class="type">bool</span> bSplit = (!bFullyContained || MinLOD &lt; MaxLOD || Index &lt; Params.FirstOcclusionNode)</span><br><span class="line">       &amp;&amp; !bShouldGroup;</span><br><span class="line"><span class="comment">//节点不可分割时，把节点添加到结果中</span></span><br><span class="line">    <span class="keyword">if</span> (!bSplit)</span><br><span class="line">    &#123;</span><br><span class="line">       MaxLOD = FMath::<span class="built_in">Min</span>(MaxLOD, Params.LODs - <span class="number">1</span>);</span><br><span class="line">       Params.<span class="built_in">AddRun</span>(MinLOD, MaxLOD, Node);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归子节点</span></span><br><span class="line">    <span class="keyword">for</span> (int32 ChildIndex = Node.FirstChild; ChildIndex &lt;= Node.LastChild; ChildIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">Traverse</span>&lt;TUseVector&gt;(Params, ChildIndex, MinLOD, MaxLOD, bFullyContained);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">CalcLOD</span><span class="params">(int32&amp; InOutMinLOD, int32&amp; InOutMaxLOD, <span class="type">const</span> FVector&amp; BoundMin, <span class="type">const</span> FVector&amp; BoundMax, <span class="type">const</span> FVector&amp; ViewOriginInLocalZero, <span class="type">const</span> FVector&amp; ViewOriginInLocalOne, <span class="type">const</span> <span class="type">float</span> (&amp;LODPlanesMin)[MAX_STATIC_MESH_LODS], <span class="type">const</span> <span class="type">float</span> (&amp;LODPlanesMax)[MAX_STATIC_MESH_LODS])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (InOutMinLOD != InOutMaxLOD)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> FVector Center = (BoundMax + BoundMin) * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> DistCenterZero = FVector::<span class="built_in">Dist</span>(Center, ViewOriginInLocalZero);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> DistCenterOne = FVector::<span class="built_in">Dist</span>(Center, ViewOriginInLocalOne);</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> HalfWidth = FVector::<span class="built_in">Dist</span>(BoundMax, BoundMin) * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> NearDot = FMath::<span class="built_in">Min</span>(DistCenterZero, DistCenterOne) - HalfWidth;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> FarDot = FMath::<span class="built_in">Max</span>(DistCenterZero, DistCenterOne) + HalfWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (InOutMaxLOD &gt; InOutMinLOD &amp;&amp; NearDot &gt; LODPlanesMax[InOutMinLOD])</span><br><span class="line">&#123;</span><br><span class="line">InOutMinLOD++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (InOutMaxLOD &gt; InOutMinLOD &amp;&amp; FarDot &lt; LODPlanesMin[InOutMaxLOD - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">InOutMaxLOD--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过可见性检查的节点会被添加到一个LOD数组中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">AddRun</span><span class="params">(TArray&lt;uint32, SceneRenderingAllocator&gt;&amp; Array, int32 FirstInstance, int32 LastInstance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Array.<span class="built_in">Num</span>() &amp;&amp; Array.<span class="built_in">Last</span>() + <span class="number">1</span> == FirstInstance)</span><br><span class="line">&#123;</span><br><span class="line">Array.<span class="built_in">Last</span>() = (uint32)LastInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Array.<span class="built_in">Add</span>((uint32)FirstInstance);</span><br><span class="line">Array.<span class="built_in">Add</span>((uint32)LastInstance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FORCEINLINE_DEBUGGABLE <span class="type">void</span> <span class="title">AddRun</span><span class="params">(int32 MinLod, int32 MaxLod, int32 FirstInstance, int32 LastInstance)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bNeedsSingleLODRuns)</span><br><span class="line">    &#123;</span><br><span class="line">       int32 CurrentLOD = bOverestimate ? MaxLod : MinLod;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (CurrentLOD &lt; MAX_STATIC_MESH_LODS)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">AddRun</span>(SingleLODRuns[CurrentLOD], FirstInstance, LastInstance);</span><br><span class="line">          TotalSingleLODInstances[CurrentLOD] += <span class="number">1</span> + LastInstance - FirstInstance;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bNeedsMultipleLODRuns)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span> (int32 Lod = MinLod; Lod &lt;= MaxLod; Lod++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (Lod &lt; MAX_STATIC_MESH_LODS)</span><br><span class="line">          &#123;</span><br><span class="line">             TotalMultipleLODInstances[Lod] += <span class="number">1</span> + LastInstance - FirstInstance;</span><br><span class="line">             <span class="built_in">AddRun</span>(MultipleLODRuns[Lod], FirstInstance, LastInstance);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提交合批数据"><a href="#提交合批数据" class="headerlink" title="提交合批数据"></a>提交合批数据</h2><p>该数组在FillDynamicMeshElements中被用于将赋值给meshbatch的numinstances字段，方便在提交drawcall的时候知道绘制多少个实例，而每个实例数据的transform data，则是在FInstancedStaticMeshVertexFactory::InitRHI接口中（可以参考笔者的VertexFactory文章），绑定到顶点buffer的其中几个属性，在ush的顶点结构声明中也有同样的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FInstancedStaticMeshVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">// toss in the instanced location stream</span></span><br><span class="line"><span class="built_in">check</span>(Data.InstanceOriginComponent.VertexBuffer);</span><br><span class="line"><span class="keyword">if</span> (Data.InstanceOriginComponent.VertexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceOriginComponent, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">check</span>(Data.InstanceTransformComponent[<span class="number">0</span>].VertexBuffer);</span><br><span class="line"><span class="keyword">if</span> (Data.InstanceTransformComponent[<span class="number">0</span>].VertexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">0</span>], <span class="number">9</span>));</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">1</span>], <span class="number">10</span>));</span><br><span class="line">Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.InstanceTransformComponent[<span class="number">2</span>], <span class="number">11</span>));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localVertexFactory.ush</span></span><br><span class="line">struct FVertexFactoryInput</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#if USE_INSTANCING &amp;&amp; !MANUAL_VERTEX_FETCH</span></span><br><span class="line">float4 InstanceOrigin : ATTRIBUTE8;  <span class="comment">// per-instance random in w </span></span><br><span class="line">half4 InstanceTransform1 : ATTRIBUTE9;  <span class="comment">// hitproxy.r + 256 * selected in .w</span></span><br><span class="line">half4 InstanceTransform2 : ATTRIBUTE10; <span class="comment">// hitproxy.g in .w</span></span><br><span class="line">half4 InstanceTransform3 : ATTRIBUTE11; <span class="comment">// hitproxy.b in .w</span></span><br><span class="line">float4 InstanceLightmapAndShadowMapUVBias : ATTRIBUTE12; </span><br><span class="line"><span class="meta">#endif //USE_INSTANCING</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MaterialTemplate.ush</span></span><br><span class="line"><span class="comment">/** Return the object&#x27;s position in world space */</span></span><br><span class="line">float3 GetObjectWorldPosition(FMaterialPixelParameters Parameters)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GetPrimitiveData(Parameters.PrimitiveId).ObjectWorldPositionAndRadius.xyz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Return the object&#x27;s position in world space. For instanced meshes, this returns the instance position. */</span></span><br><span class="line">float3 GetObjectWorldPosition(FMaterialVertexParameters Parameters)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#if USE_INSTANCING || IS_MESHPARTICLE_FACTORY</span></span><br><span class="line">       <span class="keyword">return</span> Parameters.InstanceLocalToWorld[<span class="number">3</span>].xyz;</span><br><span class="line">    <span class="meta">#else</span></span><br><span class="line">       <span class="keyword">return</span> GetPrimitiveData(Parameters.PrimitiveId).ObjectWorldPositionAndRadius.xyz;</span><br><span class="line">    <span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与GPUScene的区别"><a href="#与GPUScene的区别" class="headerlink" title="与GPUScene的区别"></a>与GPUScene的区别</h2><p>而在shader的多处对instance的transform取值中我们也可以看出，以USE_INSTANCING或其他参数作为区分，返回动态合批的instance数据（GPUScene）或者HISM的Instance数据。</p><p>这两者的区别笔者认为有以下几点：</p><ol><li>GPUScene可以合批各种场景Proxy，只要渲染状态相同即可，并且可以存储数据较多，而HISM只能合批当前的components，并且只存储Transform。</li><li>GPUScene的Instance数据是通过Struct或者Texture一起传输到GPU的，而HISM则是提前放置在Vertex Buffer中。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HierarchicalInstancedStaticMeshComponent&quot;&gt;&lt;a href=&quot;#HierarchicalInstancedStaticMeshComponent&quot; class=&quot;headerlink&quot; title=&quot;HierarchicalInstancedStaticMeshComponent&quot;&gt;&lt;/a&gt;HierarchicalInstancedStaticMeshComponent&lt;/h1&gt;&lt;p&gt;​    InstancedStaticMesh是UE针对使用相同Material，但是具有不同transform的物体的优化方案，可以将这些物体在创建时静态合批，大量减少drawcall，而InstancedStaticMesh(后续简称ISM)存在以下缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的ISM都使用相同的LOD，导致远处的ISM也会被赋予高级别LOD，造成浪费。&lt;/li&gt;
&lt;li&gt;一组ISM共享剔除，只要有一个ISM实例被绘制，那么这一组都会被绘制，剔除同理，也会造成浪费。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    因此又衍生出了HISM，可以针对一组ISM生成对应的N叉树，便于空间管理，在生成meshbatch的时候根据可见性剔除不必要的子节点，避免造成浪费。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE源码" scheme="https://ritchielambda.github.io/tags/UE%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>UE渲染工作流(二)——可见性篇</title>
    <link href="https://ritchielambda.github.io/2024/06/28/renderworkflow_visibility/"/>
    <id>https://ritchielambda.github.io/2024/06/28/renderworkflow_visibility/</id>
    <published>2024-06-28T09:09:53.000Z</published>
    <updated>2025-02-20T14:21:17.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE渲染工作流-二-——可见性篇"><a href="#UE渲染工作流-二-——可见性篇" class="headerlink" title="UE渲染工作流(二)——可见性篇"></a>UE渲染工作流(二)——可见性篇</h1><p>​    上一篇我们讨论到StaticMesh的数据从RenderData数据成员设置到VF中，然后再赋值给渲染线程的FPrimitiveSceneInfo的MeshBatch，这一篇主要讨论在渲染线程拥有了Mesh数据后，如何做可见性的过滤。</p><span id="more"></span><p>​    可见性计算的入口在FMobileSceneRenderer::InitViews，其中有三个主要函数，我们主要讨论最重要的ComputeViewVisibility，前后两个SetUp是对视对本帧数据做一些预处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PreVisibilityFrameSetup</span>(RHICmdList);</span><br><span class="line"><span class="built_in">ComputeViewVisibility</span>(RHICmdList, BasePassDepthStencilAccess, ViewCommandsPerView, DynamicIndexBuffer, DynamicVertexBuffer, DynamicReadBuffer);</span><br><span class="line"><span class="built_in">PostVisibilityFrameSetup</span>(ILCTaskData);</span><br></pre></td></tr></table></figure><p>​    ComputeViewVisibility分为几个模块执行</p><ol><li><p>更新View下的可见性Map数据结构</p></li><li><p>视锥裁剪</p></li><li><p>更新视图中隐藏/仅可见/线框绘制的图元</p></li><li><p>计算并标记视图相关性</p></li><li><p>获取动态图元的MeshBatch</p></li><li><p>设置MeshPass数据</p><p>其中1，3步骤比较直接，这里不再解读，都是直接对PrimitiveMap进行操作赋值。</p><p>这里的大部分Map都使用了FSceneBitArray结构，其实本质上是一个uint32的数组，每一个uint32的位单独代表一个Primitive，所以在操作的时候需要先找到对于的uint32，然后再操作对应的位数。</p></li></ol><h2 id="FrustumCull"><a href="#FrustumCull" class="headerlink" title="FrustumCull"></a>FrustumCull</h2><p>​    在执行视锥裁剪之前，UE先做了HLOD的更新，本篇不多赘述，后面会单独讲这个系统，大概作用是会将远处的Mesh按照一定范围，合并成一个Mesh，生成新的Material，这样的好处是可以减小drawcall，但是因为需要合并新的Mesh，所以内存会变大。</p><p>​    视锥裁剪函数入口为FrustumCull，实际算法就是根据FPrimitiveSceneInfo的绘制距离与当前视角远点对比，根据大于，等于，小于渐变距离范围分别加入到View的三个PrimitiveMap中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据primitiveid下标，填充三种map，可见/不可见/淡出</span></span><br><span class="line"><span class="keyword">if</span> (FadingBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.PotentiallyFadingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.PotentiallyFadingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex] = FadingBits;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (VisBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.PrimitiveVisibilityMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.PrimitiveVisibilityMap.<span class="built_in">GetData</span>()[WordIndex] = VisBits;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DistanceCulledBits)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">check</span>(!View.DistanceCullingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex]); <span class="comment">// this should start at zero</span></span><br><span class="line">View.DistanceCullingPrimitiveMap.<span class="built_in">GetData</span>()[WordIndex] = DistanceCulledBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ComputeAndMarkRelevanceForViewParallel"><a href="#ComputeAndMarkRelevanceForViewParallel" class="headerlink" title="ComputeAndMarkRelevanceForViewParallel"></a>ComputeAndMarkRelevanceForViewParallel</h2><p>这一步主要是通过SceneProxy的GetViewRelevance接口获取每一个proxy是否跟View相关，来决定每一个PrimitiveSceneInfo后续的绘制操作，每一个相关性的作用可以参考FPrimitiveViewRelevance类的成员，我们这里只关注它的动态/静态相关性，它们最终决定了对应的PrimitiveSceneInfo是通过哪种绘制路径来绘制。</p><p><img src="/2024/06/28/renderworkflow_visibility/renderpath.png" alt></p><p>​    绘制路径是UE针对静态物体的一种优化手段，UE的渲染数据流向为上图从左到右，一层一层数据归集，最终生成一个FMeshDrawCommands丢给RHI线程调用底层图形API，但是对于场景中那些不怎么变化的物体，不需要每帧都重复这个流程，可以把他们的MeshDrawCommands缓存下来，这就是静态绘制路径，而需要每帧都重新生成的是动态绘制路径。</p><p>这一步主要通过FRelevancePacket对View.PrimitiveVisibilityMap遍历进行多线程计算，PrimitiveVisibilityMap已经在2，3步骤中被更新，主要执行其接口AnyThreadTask()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnyThreadTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ComputeRelevance</span>();</span><br><span class="line">    <span class="built_in">MarkRelevant</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ComputeRelevance"><a href="#ComputeRelevance" class="headerlink" title="ComputeRelevance"></a>ComputeRelevance</h3><p>这一步主要就是通过SceneProxy的GetViewRelevance接口获取每一个proxy的相关性，加入不同的数组队列中保存，这里我们关注两个相关性：静态/动态。对于静态会添加到RelevantStaticPrimitives，对于动态会对函数的返回值OutHasDynamicMeshElementsMasks做标记，在函数外再做处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ComputeRelevance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 Index = <span class="number">0</span>; Index &lt; Input.NumPrims; Index++)</span><br><span class="line">&#123;</span><br><span class="line">int32 BitIndex = Input.Prims[Index];</span><br><span class="line">FPrimitiveSceneInfo* PrimitiveSceneInfo = Scene-&gt;Primitives[BitIndex];</span><br><span class="line">FPrimitiveViewRelevance&amp; ViewRelevance = <span class="built_in">const_cast</span>&lt;FPrimitiveViewRelevance&amp;&gt;(View.PrimitiveViewRelevanceMap[BitIndex]);</span><br><span class="line">ViewRelevance = PrimitiveSceneInfo-&gt;Proxy-&gt;<span class="built_in">GetViewRelevance</span>(&amp;View);</span><br><span class="line">ViewRelevance.bInitializedThisFrame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bStaticRelevance = ViewRelevance.bStaticRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bDrawRelevance = ViewRelevance.bDrawRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bDynamicRelevance = ViewRelevance.bDynamicRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bShadowRelevance = ViewRelevance.bShadowRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bEditorRelevance = ViewRelevance.bEditorPrimitiveRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bEditorSelectionRelevance = ViewRelevance.bEditorStaticSelectionRelevance;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> bTranslucentRelevance = ViewRelevance.<span class="built_in">HasTranslucency</span>();</span><br><span class="line"><span class="comment">//对静态相关性处理</span></span><br><span class="line"><span class="keyword">if</span> (bStaticRelevance &amp;&amp; (bDrawRelevance || bShadowRelevance))</span><br><span class="line">&#123;</span><br><span class="line">RelevantStaticPrimitives.<span class="built_in">AddPrim</span>(BitIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (bEditorRelevance)</span><br><span class="line">&#123;</span><br><span class="line">++NumVisibleDynamicEditorPrimitives;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GIsEditor)</span><br><span class="line">&#123;</span><br><span class="line">OutHasDynamicEditorMeshElementsMasks[BitIndex] |= ViewBit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//动态相关性处理</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bDynamicRelevance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Keep track of visible dynamic primitives.</span></span><br><span class="line">++NumVisibleDynamicPrimitives;</span><br><span class="line">OutHasDynamicMeshElementsMasks[BitIndex] |= ViewBit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ViewRelevance.bHasSimpleLights)</span><br><span class="line">&#123;</span><br><span class="line">VisibleDynamicPrimitivesWithSimpleLights.<span class="built_in">AddPrim</span>(PrimitiveSceneInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看一下StaticMesh是如何决定是否是静态的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FPrimitiveViewRelevance <span class="title">FStaticMeshSceneProxy::GetViewRelevance</span><span class="params">(<span class="type">const</span> FSceneView* View)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">checkSlow</span>(<span class="built_in">IsInParallelRenderingThread</span>());</span><br><span class="line"></span><br><span class="line">    FPrimitiveViewRelevance Result;</span><br><span class="line">    Result.bDrawRelevance = <span class="built_in">IsShown</span>(View) &amp;&amp; View-&gt;Family-&gt;EngineShowFlags.StaticMeshes;</span><br><span class="line">    Result.bRenderCustomDepth = <span class="built_in">ShouldRenderCustomDepth</span>();</span><br><span class="line">    Result.bRenderInMainPass = <span class="built_in">ShouldRenderInMainPass</span>();</span><br><span class="line">    Result.bUsesLightingChannels = <span class="built_in">GetLightingChannelMask</span>() != <span class="built_in">GetDefaultLightingChannelMask</span>();</span><br><span class="line">    Result.bTranslucentSelfShadow = bCastVolumetricTranslucentShadow;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATICMESH_ENABLE_DEBUG_RENDERING</span></span><br><span class="line">    <span class="type">bool</span> bDrawSimpleCollision = <span class="literal">false</span>, bDrawComplexCollision = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bInCollisionView = <span class="built_in">IsCollisionView</span>(View-&gt;Family-&gt;EngineShowFlags, bDrawSimpleCollision, bDrawComplexCollision);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">bool</span> bInCollisionView = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bAllowStaticLighting = FReadOnlyCVARCache::<span class="built_in">Get</span>().bAllowStaticLighting;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">       <span class="comment">// Force down dynamic rendering path if invalid lightmap settings, so we can apply an error material in DrawRichMesh</span></span><br><span class="line">       (bAllowStaticLighting &amp;&amp; <span class="built_in">HasStaticLighting</span>() &amp;&amp; !<span class="built_in">HasValidSettingsForStaticLighting</span>()) ||</span><br><span class="line">       <span class="built_in">HasViewDependentDPG</span>()</span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">       Result.bDynamicRelevance = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       Result.bStaticRelevance = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result.bShadowRelevance = <span class="built_in">IsShadowCast</span>(View);</span><br><span class="line"></span><br><span class="line">    MaterialRelevance.<span class="built_in">SetPrimitiveViewRelevance</span>(Result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!View-&gt;Family-&gt;EngineShowFlags.Materials </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> STATICMESH_ENABLE_DEBUG_RENDERING</span></span><br><span class="line">       || bInCollisionView</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">    &#123;</span><br><span class="line">       Result.bOpaque = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result.bVelocityRelevance = <span class="built_in">IsMovable</span>() &amp;&amp; Result.bOpaque &amp;&amp; Result.bRenderInMainPass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到有几个判断决定，我们看下具体实现，其实就是判断在编辑器中勾选的移动性，以及是否支持静态光，至于Lightmap的判断我们这里暂不展开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UPrimitiveComponent::HasStaticLighting</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Mobility == EComponentMobility::Static) || LightmapType == ELightmapType::ForceSurface) &amp;&amp; <span class="built_in">SupportsStaticLighting</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面是StaticMeshComponent的实现</span></span><br><span class="line"><span class="comment">/** Whether the component type supports static lighting. */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">SupportsStaticLighting</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">UStaticMeshComponent::HasValidSettingsForStaticLighting</span><span class="params">(<span class="type">bool</span> bOverlookInvalidComponents)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bOverlookInvalidComponents &amp;&amp; !<span class="built_in">GetStaticMesh</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Return true for invalid components, this is used during the map check where those invalid components will be warned about separately</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">int32 LightMapWidth = <span class="number">0</span>;</span><br><span class="line">int32 LightMapHeight = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">GetLightMapResolution</span>(LightMapWidth, LightMapHeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Super::<span class="built_in">HasValidSettingsForStaticLighting</span>(bOverlookInvalidComponents) </span><br><span class="line">&amp;&amp; <span class="built_in">GetStaticMesh</span>()</span><br><span class="line">&amp;&amp; <span class="built_in">UsesTextureLightmaps</span>(LightMapWidth, LightMapHeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​    我们大致可以判断出什么样的StaticMeshComponent是动态相关性：支持StaticLighting的，但是没有设置对应的Lightmap。</p><h3 id="MarkRelevant"><a href="#MarkRelevant" class="headerlink" title="MarkRelevant"></a>MarkRelevant</h3><p>​    这一步只对静态相关性的Primitive处理，会根据PrimitiveSceneInfo的StaticMeshRelevances以及shadingpath，把PrimitiveSceneInfo的MeshDrawCommands添加到不同Pass的数组队列中，而静态Primitive的MeshDrawCommands在上一篇中已经在CacheMeshDrawCommands中被保存起来了，这里更像是做一个归类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MarkRelevant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">for</span> (int32 StaticPrimIndex = <span class="number">0</span>, Num = RelevantStaticPrimitives.NumPrims; StaticPrimIndex &lt; Num; ++StaticPrimIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (StaticMeshRelevance.bUseForMaterial &amp;&amp; (ViewRelevance.bRenderInMainPass || ViewRelevance.bRenderCustomDepth))</span><br><span class="line">&#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line"><span class="comment">// Specific logic for mobile packets</span></span><br><span class="line"><span class="keyword">if</span> (ShadingPath == EShadingPath::Mobile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Skydome must not be added to base pass bucket</span></span><br><span class="line"><span class="keyword">if</span> (!StaticMeshRelevance.bUseSkyMaterial)</span><br><span class="line">&#123;</span><br><span class="line">                        <span class="comment">//添加到basepass的队列中</span></span><br><span class="line">DrawCommandPacket.<span class="built_in">AddCommandsForMesh</span>(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::BasePass);</span><br><span class="line">DrawCommandPacket.<span class="built_in">AddCommandsForMesh</span>(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::MobileBasePassCSM);</span><br><span class="line">&#125;</span><br><span class="line">                   &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddCommandsForMesh</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 PrimitiveIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FPrimitiveSceneInfo* InPrimitiveSceneInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FStaticMeshBatchRelevance&amp; RESTRICT StaticMeshRelevance, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FStaticMeshBatch&amp; RESTRICT StaticMesh, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FScene* RESTRICT Scene, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bCanCache, </span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPass::Type PassType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bUseCachedMeshCommand = bUseCachedMeshDrawCommands</span><br><span class="line">       &amp;&amp; !!(FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::CachedMeshCommands)</span><br><span class="line">       &amp;&amp; StaticMeshRelevance.bSupportsCachingMeshDrawCommands</span><br><span class="line">       &amp;&amp; bCanCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bUseCachedMeshCommand)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 StaticMeshCommandInfoIndex = StaticMeshRelevance.<span class="built_in">GetStaticMeshCommandInfoIndex</span>(PassType);</span><br><span class="line">       <span class="keyword">if</span> (StaticMeshCommandInfoIndex &gt;= <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FCachedMeshDrawCommandInfo&amp; CachedMeshDrawCommand = InPrimitiveSceneInfo-&gt;StaticMeshCommandInfos[StaticMeshCommandInfoIndex];</span><br><span class="line">          <span class="type">const</span> FCachedPassMeshDrawList&amp; SceneDrawList = Scene-&gt;CachedDrawLists[PassType];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// AddUninitialized_GetRef()</span></span><br><span class="line">           <span class="comment">//这里的MeshdrawCommands是根据pass来分类存储</span></span><br><span class="line">          VisibleCachedDrawCommands[(uint32)PassType].<span class="built_in">AddUninitialized</span>();</span><br><span class="line">          FVisibleMeshDrawCommand&amp; NewVisibleMeshDrawCommand = VisibleCachedDrawCommands[(uint32)PassType].<span class="built_in">Last</span>();</span><br><span class="line"></span><br><span class="line">          <span class="type">const</span> FMeshDrawCommand* MeshDrawCommand = CachedMeshDrawCommand.StateBucketId &gt;= <span class="number">0</span></span><br><span class="line">             ? &amp;Scene-&gt;CachedMeshDrawCommandStateBuckets[PassType].<span class="built_in">GetByElementId</span>(CachedMeshDrawCommand.StateBucketId).Key</span><br><span class="line">             : &amp;SceneDrawList.MeshDrawCommands[CachedMeshDrawCommand.CommandIndex];</span><br><span class="line"></span><br><span class="line">          NewVisibleMeshDrawCommand.<span class="built_in">Setup</span>(</span><br><span class="line">             MeshDrawCommand,</span><br><span class="line">             PrimitiveIndex,</span><br><span class="line">             PrimitiveIndex,</span><br><span class="line">             CachedMeshDrawCommand.StateBucketId,</span><br><span class="line">             CachedMeshDrawCommand.MeshFillMode,</span><br><span class="line">             CachedMeshDrawCommand.MeshCullMode,</span><br><span class="line">             CachedMeshDrawCommand.SortKey);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       NumDynamicBuildRequestElements[PassType] += StaticMeshRelevance.NumElements;</span><br><span class="line">       DynamicBuildRequests[PassType].<span class="built_in">Add</span>(&amp;StaticMesh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RenderThreadFinalize"><a href="#RenderThreadFinalize" class="headerlink" title="RenderThreadFinalize"></a>RenderThreadFinalize</h3><p>​    这一步主要是做一些数据拷贝的操作，把Packet处理后的数据拷贝Packet中的数据成员，这里我们只关注MeshDrawCommands的转移，WriteViewCommands其实是ComputeViewVisibility调用时传入的参数，这个参数同样在SetupMeshPass中被用来存放动态绘制指令，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderThreadFinalize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">&#123;</span><br><span class="line">FPassDrawCommandArray&amp; SrcCommands = DrawCommandPacket.VisibleCachedDrawCommands[PassIndex];</span><br><span class="line">FMeshCommandOneFrameArray&amp; DstCommands = WriteViewCommands.MeshCommands[PassIndex];</span><br><span class="line">    <span class="comment">//赋值静态绘制指令</span></span><br><span class="line"><span class="keyword">if</span> (SrcCommands.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(SrcCommands[<span class="number">0</span>]) == <span class="built_in">sizeof</span>(DstCommands[<span class="number">0</span>]), <span class="string">&quot;Memcpy sizes must match.&quot;</span>);</span><br><span class="line"><span class="type">const</span> int32 PrevNum = DstCommands.<span class="built_in">AddUninitialized</span>(SrcCommands.<span class="built_in">Num</span>());</span><br><span class="line">FMemory::<span class="built_in">Memcpy</span>(&amp;DstCommands[PrevNum], &amp;SrcCommands[<span class="number">0</span>], SrcCommands.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(SrcCommands[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//不支持缓存会放在这里，等到生成动态绘制指令时再生成</span></span><br><span class="line">    FPassDrawCommandBuildRequestArray&amp; SrcRequests = DrawCommandPacket.DynamicBuildRequests[PassIndex];</span><br><span class="line">TArray&lt;<span class="type">const</span> FStaticMeshBatch*, SceneRenderingAllocator&gt;&amp; DstRequests = WriteViewCommands.DynamicMeshCommandBuildRequests[PassIndex];</span><br><span class="line"><span class="keyword">if</span> (SrcRequests.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(SrcRequests[<span class="number">0</span>]) == <span class="built_in">sizeof</span>(DstRequests[<span class="number">0</span>]), <span class="string">&quot;Memcpy sizes must match.&quot;</span>);</span><br><span class="line"><span class="type">const</span> int32 PrevNum = DstRequests.<span class="built_in">AddUninitialized</span>(SrcRequests.<span class="built_in">Num</span>());</span><br><span class="line">FMemory::<span class="built_in">Memcpy</span>(&amp;DstRequests[PrevNum], &amp;SrcRequests[<span class="number">0</span>], SrcRequests.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(SrcRequests[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GatherDynamicMeshElements"><a href="#GatherDynamicMeshElements" class="headerlink" title="GatherDynamicMeshElements"></a>GatherDynamicMeshElements</h2><p>​    上一步在标记相关性后，动态相关性的primitive被保存在了OutHasDynamicEditorMeshElementsMasks结构中，这一步就是对动态相关性的primitive重新收集MeshBatch，内部调用了GetDynamicMeshElements来生成MeshBatch，这一步其实与静态绘制的primitive收集meshbatch的流程类似，GetDynamicMeshElements内部调用了统一的接口GetMeshElement，最终把meshbatch收集到参数Collector中，需要注意的是最后Collector收集MeshBatch的地方，在GatherDynamicMeshElements的开头部分Collector注册了View.DynamicMeshElements到MeshBatchs中，所以这里其实把MeshBatch按照View添加进了DynamicMeshElements数据结构，后面没有用到collector的原因正在于此。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FMeshElementCollector::<span class="built_in">AddMesh</span>(int32 ViewIndex, FMeshBatch&amp; MeshBatch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    TArray&lt;FMeshBatchAndRelevance,SceneRenderingAllocator&gt;&amp; ViewMeshBatches = *MeshBatches[ViewIndex];</span><br><span class="line"><span class="keyword">new</span> (ViewMeshBatches) <span class="built_in">FMeshBatchAndRelevance</span>(MeshBatch, PrimitiveSceneProxy, FeatureLevel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SetupMeshPass"><a href="#SetupMeshPass" class="headerlink" title="SetupMeshPass"></a>SetupMeshPass</h2><p>到这一步，我们回顾下现在拥有哪些数据：按照pass分类存储的静态绘制路径的MeshDrawCommands，动态绘制路径的MeshBatch。</p><p>SetupMeshPass主要通过DispatchPassSetup，分发任务，来实现View.ParallelMeshDrawCommandPasses结构的填充，以便在后续执行对应Pass的时候提交MeshDrawCommands。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FSceneRenderer::SetupMeshPass</span><span class="params">(FViewInfo&amp; View, FExclusiveDepthStencil::Type BasePassDepthStencilAccess, FViewCommands&amp; ViewCommands)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">    <span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> EMeshPass::Type PassType = (EMeshPass::Type)PassIndex;</span><br><span class="line">       <span class="keyword">if</span> ((FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::MainView) != EMeshPassFlags::None)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// Mobile: BasePass and MobileBasePassCSM lists need to be merged and sorted after shadow pass.</span></span><br><span class="line">          <span class="keyword">if</span> (ShadingPath == EShadingPath::Mobile &amp;&amp; (PassType == EMeshPass::BasePass || PassType == EMeshPass::MobileBasePassCSM))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          PassProcessorCreateFunction CreateFunction = FPassProcessorManager::<span class="built_in">GetCreateFunction</span>(ShadingPath, PassType);</span><br><span class="line">          FMeshPassProcessor* MeshPassProcessor = <span class="built_in">CreateFunction</span>(Scene, &amp;View, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">          FParallelMeshDrawCommandPass&amp; Pass = View.ParallelMeshDrawCommandPasses[PassIndex];</span><br><span class="line">          Pass.<span class="built_in">DispatchPassSetup</span>(</span><br><span class="line">             Scene,</span><br><span class="line">             View,</span><br><span class="line">             PassType,</span><br><span class="line">             BasePassDepthStencilAccess,</span><br><span class="line">             MeshPassProcessor,</span><br><span class="line">             View.DynamicMeshElements,</span><br><span class="line">             &amp;View.DynamicMeshElementsPassRelevance,</span><br><span class="line">             View.NumVisibleDynamicMeshElements[PassType],</span><br><span class="line">             ViewCommands.DynamicMeshCommandBuildRequests[PassType],</span><br><span class="line">             ViewCommands.NumDynamicMeshCommandBuildRequestElements[PassType],</span><br><span class="line">             ViewCommands.MeshCommands[PassIndex]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DispatchPassSetup内部会设置FMeshDrawCommandPassSetupTaskContext的数据，然后多线程执行FMeshDrawCommandPassSetupTask，我们看下Task的内部实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnyThreadTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Mobile base pass is a special case, as final lists is created from two mesh passes based on CSM visibility.</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bMobileShadingBasePass = Context.ShadingPath == EShadingPath::Mobile &amp;&amp; Context.PassType == EMeshPass::BasePass;</span><br><span class="line">    <span class="comment">// On SM5 Mobile platform, still want the same sorting</span></span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> bMobileVulkanSM5BasePass = <span class="built_in">IsVulkanMobileSM5Platform</span>(Context.ShaderPlatform) &amp;&amp; Context.PassType == EMeshPass::BasePass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bMobileShadingBasePass)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">MergeMobileBasePassMeshDrawCommands</span>(</span><br><span class="line">          Context.View-&gt;MobileCSMVisibilityInfo,</span><br><span class="line">          Context.PrimitiveBounds-&gt;<span class="built_in">Num</span>(),</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MobileBasePassCSMMeshDrawCommands</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">       <span class="built_in">GenerateMobileBasePassDynamicMeshDrawCommands</span>(</span><br><span class="line">          *Context.View,</span><br><span class="line">          Context.ShadingPath,</span><br><span class="line">          Context.PassType,</span><br><span class="line">          Context.MeshPassProcessor,</span><br><span class="line">          Context.MobileBasePassCSMMeshPassProcessor,</span><br><span class="line">          *Context.DynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshElementsPassRelevance,</span><br><span class="line">          Context.NumDynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshCommandBuildRequests,</span><br><span class="line">          Context.NumDynamicMeshCommandBuildRequestElements,</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MeshDrawCommandStorage,</span><br><span class="line">          Context.MinimalPipelineStatePassSet,</span><br><span class="line">          Context.NeedsShaderInitialisation</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">GenerateDynamicMeshDrawCommands</span>(</span><br><span class="line">          *Context.View,</span><br><span class="line">          Context.ShadingPath,</span><br><span class="line">          Context.PassType,</span><br><span class="line">          Context.MeshPassProcessor,</span><br><span class="line">          *Context.DynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshElementsPassRelevance,</span><br><span class="line">          Context.NumDynamicMeshElements,</span><br><span class="line">          Context.DynamicMeshCommandBuildRequests,</span><br><span class="line">          Context.NumDynamicMeshCommandBuildRequestElements,</span><br><span class="line">          Context.MeshDrawCommands,</span><br><span class="line">          Context.MeshDrawCommandStorage,</span><br><span class="line">          Context.MinimalPipelineStatePassSet,</span><br><span class="line">          Context.NeedsShaderInitialisation</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Context.MeshDrawCommands.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span> (Context.PassType != EMeshPass::Num)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">ApplyViewOverridesToMeshDrawCommands</span>(</span><br><span class="line">             Context.ShadingPath,</span><br><span class="line">             Context.PassType,</span><br><span class="line">             Context.bReverseCulling,</span><br><span class="line">             Context.bRenderSceneTwoSided,</span><br><span class="line">             Context.BasePassDepthStencilAccess,</span><br><span class="line">             Context.DefaultBasePassDepthStencilAccess,</span><br><span class="line">             Context.MeshDrawCommands,</span><br><span class="line">             Context.MeshDrawCommandStorage,</span><br><span class="line">             Context.MinimalPipelineStatePassSet,</span><br><span class="line">             Context.NeedsShaderInitialisation,</span><br><span class="line">             Context.TempVisibleMeshDrawCommands</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Update sort keys.</span></span><br><span class="line">       <span class="keyword">if</span> (bMobileShadingBasePass || bMobileVulkanSM5BasePass)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">UpdateMobileBasePassMeshSortKeys</span>(</span><br><span class="line">             Context.ViewOrigin,</span><br><span class="line">             *Context.PrimitiveBounds,</span><br><span class="line">             Context.MeshDrawCommands</span><br><span class="line">             );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (Context.TranslucencyPass != ETranslucencyPass::TPT_MAX)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">UpdateTranslucentMeshSortKeys</span>(</span><br><span class="line">             Context.TranslucentSortPolicy,</span><br><span class="line">             Context.TranslucentSortAxis,</span><br><span class="line">             Context.ViewOrigin,</span><br><span class="line">             Context.ViewMatrix,</span><br><span class="line">             *Context.PrimitiveBounds,</span><br><span class="line">             Context.TranslucencyPass,</span><br><span class="line">             Context.MeshDrawCommands</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_SortVisibleMeshDrawCommands);</span><br><span class="line">          Context.MeshDrawCommands.<span class="built_in">Sort</span>(<span class="built_in">FCompareFMeshDrawCommands</span>());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (Context.bUseGPUScene)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">BuildMeshDrawCommandPrimitiveIdBuffer</span>(</span><br><span class="line">             Context.bDynamicInstancing,</span><br><span class="line">             Context.MeshDrawCommands,</span><br><span class="line">             Context.MeshDrawCommandStorage,</span><br><span class="line">             Context.PrimitiveIdBufferData,</span><br><span class="line">             Context.PrimitiveIdBufferDataSize,</span><br><span class="line">             Context.TempVisibleMeshDrawCommands,</span><br><span class="line">             Context.MaxInstances,</span><br><span class="line">             Context.VisibleMeshDrawCommandsNum,</span><br><span class="line">             Context.NewPassVisibleMeshDrawCommandsNum,</span><br><span class="line">             Context.ShaderPlatform,</span><br><span class="line">             Context.InstanceFactor</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    Task主要实现以下几点：</p><ol><li>GenerateDynamicMeshDrawCommands</li><li>ApplyViewOverridesToMeshDrawCommands</li><li>Update/SortMeshDrawCommands</li><li>BuildMeshDrawCommandPrimitiveIdBuffer</li></ol><h3 id="GenerateDynamicMeshDrawCommands"><a href="#GenerateDynamicMeshDrawCommands" class="headerlink" title="GenerateDynamicMeshDrawCommands"></a>GenerateDynamicMeshDrawCommands</h3><p>​    这一步和上一篇的CacheMeshDrawCommands处理基本一致，都是通过processor处理MeshBatch生成MeshDrawCommands，生成的MeshDrawCommands会被收集到函数开头填入Context的VisibleCommands中，而这个VisibleCommands经过层层传递，其实就是SetupMeshPass传入的最后一个参数，与RenderThreadFinalize中存储静态指令的结构相同，这样就把静态和动态绘制指令保存在一起，可以发现这个参数变量在ComputeViewVisibility之后就没有被其他地方使用，答案就在DispatchPassSetup中，对应Pass的FMeshCommandOneFrameArray数据结构被MemSwap给了对应Pass的TaskContext，在后续提交渲染指令时，Pass会直接拿Task内的指令来提交。</p><p>​    另外这里里的数据来源是GatherDynamicMeshElements中收集来的MeshBatch，但是还有DynamicMeshCommandBuildRequests，这个是在把静态绘制指令按照Pass存储的时候，如果当前Pass不支持缓存，那就不会放在CacheCommands中，而是放在BuildRequests里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateDynamicMeshDrawCommands</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FViewInfo&amp; View,</span></span></span><br><span class="line"><span class="params"><span class="function">    EShadingPath ShadingPath,</span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPass::Type PassType,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshPassProcessor* PassMeshProcessor,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;FMeshBatchAndRelevance, SceneRenderingAllocator&gt;&amp; DynamicMeshElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;FMeshPassMask, SceneRenderingAllocator&gt;* DynamicMeshElementsPassRelevance,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 MaxNumDynamicMeshElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TArray&lt;<span class="type">const</span> FStaticMeshBatch*, SceneRenderingAllocator&gt;&amp; DynamicMeshCommandBuildRequests,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 MaxNumBuildRequestElements,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; VisibleCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    FDynamicMeshDrawCommandStorage&amp; MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">    FGraphicsMinimalPipelineStateSet&amp; MinimalPipelineStatePassSet,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>&amp; NeedsShaderInitialisation</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_GenerateDynamicMeshDrawCommands);</span><br><span class="line">    <span class="built_in">check</span>(PassMeshProcessor);</span><br><span class="line">    <span class="built_in">check</span>((PassType == EMeshPass::Num) == (DynamicMeshElementsPassRelevance == <span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function">FDynamicPassMeshDrawListContext <span class="title">DynamicPassMeshDrawListContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">       MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">       VisibleCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">       MinimalPipelineStatePassSet,</span></span></span><br><span class="line"><span class="params"><span class="function">       NeedsShaderInitialisation</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    PassMeshProcessor-&gt;<span class="built_in">SetDrawListContext</span>(&amp;DynamicPassMeshDrawListContext);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 NumCommandsBefore = VisibleCommands.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="type">const</span> int32 NumDynamicMeshBatches = DynamicMeshElements.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; NumDynamicMeshBatches; MeshIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">if</span> (!DynamicMeshElementsPassRelevance || (*DynamicMeshElementsPassRelevance)[MeshIndex].<span class="built_in">Get</span>(PassType))</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="type">const</span> FMeshBatchAndRelevance&amp; MeshAndRelevance = DynamicMeshElements[MeshIndex];</span><br><span class="line">             <span class="type">const</span> uint64 BatchElementMask = ~<span class="number">0ull</span>;</span><br><span class="line"></span><br><span class="line">             PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(*MeshAndRelevance.Mesh, BatchElementMask, MeshAndRelevance.PrimitiveSceneProxy);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">const</span> int32 NumCommandsBefore = VisibleCommands.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="type">const</span> int32 NumStaticMeshBatches = DynamicMeshCommandBuildRequests.<span class="built_in">Num</span>();</span><br><span class="line">       <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; NumStaticMeshBatches; MeshIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FStaticMeshBatch* StaticMeshBatch = DynamicMeshCommandBuildRequests[MeshIndex];</span><br><span class="line">          <span class="type">const</span> uint64 DefaultBatchElementMask = ~<span class="number">0ul</span>;</span><br><span class="line">          PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(*StaticMeshBatch, DefaultBatchElementMask, StaticMeshBatch-&gt;PrimitiveSceneInfo-&gt;Proxy, StaticMeshBatch-&gt;Id);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyViewOverridesToMeshDrawCommands"><a href="#ApplyViewOverridesToMeshDrawCommands" class="headerlink" title="ApplyViewOverridesToMeshDrawCommands"></a>ApplyViewOverridesToMeshDrawCommands</h3><p>​    这一步是根据View的一些特殊需求，重新设置MeshDrawCommands的pipeline状态。</p><h3 id="Update-SortMeshDrawCommands"><a href="#Update-SortMeshDrawCommands" class="headerlink" title="Update/SortMeshDrawCommands"></a>Update/SortMeshDrawCommands</h3><p>​    至此，动态/静态MeshDrawCommands已经全部存储在Pass对应的TaskContext.MeshDrawCommands下，但是我们需要对透明/不透明的MeshDrawCommands进行排序。</p><p>​    首先要更新MeshDrawCommands的SortKeys，然后根据Key排序。有三种排序方式：物体与视角中心距离，沿着某个轴排序，投影深度排序。排序结果会存储在FMeshDrawCommandSortKey中，其是由一个uint64的union来实现，有三种情况：BassPass，透明Pass，通用Pass。根据位域高低位不同来实现大小比较，先声明的位域是低位，比如对于透明Pass来说，先比较优先级（高位），然后是距离，最后是同一个Primitive的不同MeshID。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UpdateTranslucentMeshSortKeys</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ETranslucentSortPolicy::Type TranslucentSortPolicy,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FVector&amp; TranslucentSortAxis,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FVector&amp; ViewOrigin,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> FMatrix&amp; ViewMatrix,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> TArray&lt;<span class="keyword">struct</span> FPrimitiveBounds&gt;&amp; PrimitiveBounds,</span></span></span><br><span class="line"><span class="params"><span class="function">ETranslucencyPass::Type TranslucencyPass, </span></span></span><br><span class="line"><span class="params"><span class="function">FMeshCommandOneFrameArray&amp; VisibleMeshCommands</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_UpdateTranslucentMeshSortKeys);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int32 CommandIndex = <span class="number">0</span>; CommandIndex &lt; VisibleMeshCommands.<span class="built_in">Num</span>(); ++CommandIndex)</span><br><span class="line">&#123;</span><br><span class="line">FVisibleMeshDrawCommand&amp; VisibleCommand = VisibleMeshCommands[CommandIndex];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> int32 PrimitiveIndex = VisibleCommand.ScenePrimitiveId;</span><br><span class="line"><span class="type">const</span> FVector BoundsOrigin = PrimitiveIndex &gt;= <span class="number">0</span> ? PrimitiveBounds[PrimitiveIndex].BoxSphereBounds.Origin : FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> Distance = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">if</span> (TranslucentSortPolicy == ETranslucentSortPolicy::SortByDistance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//sort based on distance to the view position, view rotation is not a factor</span></span><br><span class="line">Distance = (BoundsOrigin - ViewOrigin).<span class="built_in">Size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (TranslucentSortPolicy == ETranslucentSortPolicy::SortAlongAxis)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Sort based on enforced orthogonal distance</span></span><br><span class="line"><span class="type">const</span> FVector CameraToObject = BoundsOrigin - ViewOrigin;</span><br><span class="line">Distance = FVector::<span class="built_in">DotProduct</span>(CameraToObject, TranslucentSortAxis);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Sort based on projected Z distance</span></span><br><span class="line"><span class="built_in">check</span>(TranslucentSortPolicy == ETranslucentSortPolicy::SortByProjectedZ);</span><br><span class="line">Distance = ViewMatrix.<span class="built_in">TransformPosition</span>(BoundsOrigin).Z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Patch distance inside translucent mesh sort key.</span></span><br><span class="line">FMeshDrawCommandSortKey SortKey;</span><br><span class="line">SortKey.PackedData = VisibleCommand.SortKey.PackedData;</span><br><span class="line">SortKey.Translucent.Distance = (uint32)~<span class="built_in">BitInvertIfNegativeFloat</span>(*((uint32*)&amp;Distance));</span><br><span class="line">VisibleCommand.SortKey.PackedData = SortKey.PackedData;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RENDERER_API</span> FMeshDrawCommandSortKey</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line">&#123;</span><br><span class="line">uint64 PackedData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 VertexShaderHash: <span class="number">16</span>; <span class="comment">// Order by vertex shader&#x27;s hash.</span></span><br><span class="line">uint64 PixelShaderHash: <span class="number">32</span>; <span class="comment">// Order by pixel shader&#x27;s hash.</span></span><br><span class="line">uint64 Masked: <span class="number">16</span>; <span class="comment">// First order by masked.</span></span><br><span class="line">&#125; BasePass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">uint64 MeshIdInPrimitive: <span class="number">16</span>; <span class="comment">// Order meshes belonging to the same primitive by a stable id.</span></span><br><span class="line">uint64 Distance: <span class="number">32</span>; <span class="comment">// Order by distance.</span></span><br><span class="line">uint64 Priority: <span class="number">16</span>; <span class="comment">// First order by priority.</span></span><br><span class="line">&#125; Translucent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">uint64 VertexShaderHash : <span class="number">32</span>;<span class="comment">// Order by vertex shader&#x27;s hash.</span></span><br><span class="line">uint64 PixelShaderHash : <span class="number">32</span>;<span class="comment">// First order by pixel shader&#x27;s hash.</span></span><br><span class="line">&#125; Generic;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BuildMeshDrawCommandPrimitiveIdBuffer"><a href="#BuildMeshDrawCommandPrimitiveIdBuffer" class="headerlink" title="BuildMeshDrawCommandPrimitiveIdBuffer"></a>BuildMeshDrawCommandPrimitiveIdBuffer</h3><p>这一步主要是为了合批，在GPUScene中有讲，主要是将相同渲染此处不展开。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;UE渲染工作流-二-——可见性篇&quot;&gt;&lt;a href=&quot;#UE渲染工作流-二-——可见性篇&quot; class=&quot;headerlink&quot; title=&quot;UE渲染工作流(二)——可见性篇&quot;&gt;&lt;/a&gt;UE渲染工作流(二)——可见性篇&lt;/h1&gt;&lt;p&gt;​    上一篇我们讨论到StaticMesh的数据从RenderData数据成员设置到VF中，然后再赋值给渲染线程的FPrimitiveSceneInfo的MeshBatch，这一篇主要讨论在渲染线程拥有了Mesh数据后，如何做可见性的过滤。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE源码" scheme="https://ritchielambda.github.io/tags/UE%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>UE渲染工作流(一)——数据篇</title>
    <link href="https://ritchielambda.github.io/2024/06/18/renderworkflow_data/"/>
    <id>https://ritchielambda.github.io/2024/06/18/renderworkflow_data/</id>
    <published>2024-06-18T19:47:53.000Z</published>
    <updated>2025-02-20T14:21:17.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE渲染工作流-一-——数据篇"><a href="#UE渲染工作流-一-——数据篇" class="headerlink" title="UE渲染工作流(一)——数据篇"></a>UE渲染工作流(一)——数据篇</h1><p>​    UE的渲染工作流基于原生API做了非常多的优化和封装，需要经常查阅和回顾这些工作流和数据结构，才能理解其中的奥妙。本篇内容要讨论的是数据准备篇，主要包含一个StaticMesh被放入场景中后，它的渲染数据是如何被整理应用的。注意：本篇只讲UE的部分工作流程，对于其中某个模块的具体算法实现细节不会不过解读，需要额外查阅资料，如果有时间，笔者会尽量记录在之后的文章中。</p><span id="more"></span><h2 id="StaticMesh-gt-SceneProxy"><a href="#StaticMesh-gt-SceneProxy" class="headerlink" title="StaticMesh-&gt;SceneProxy"></a>StaticMesh-&gt;SceneProxy</h2><p>​    在UE中，一个最小的可渲染物体组件是UPrimitiveComponent(GameThread)，它渲染线程中的FPrimitiveSceneProxy一一对应，我们以最常用的一个Component说起：UStaticMeshComponent，它包含了最关键的渲染数据成员：UStaticMesh。原生的顶点数据已经预先存储在了StaticMesh的成员RenderData中，数据是如何由FBX模块导入生成的，不是本章关注的内容，略去不讲。</p><p>​    当一个StaticMesh被拖入场景中时，会调用UStaticMesh::PostLoad，然后执行RenderData的InitResources，生成我们经常在API中见到的VertexBuffer，以及VertexDeclaration。关于顶点工厂的内容，这里也不展开讲述，感兴趣的同学可以参考另一篇文章：。</p><p>​    当一个图元需要被更新渲染信息时，会调用FScene::AddPrimitive()，在其中创建对应的FPrimitiveSceneProxy和FScenePrimitiveInfo，FPrimitiveSceneProxy是图元在渲染线程的代理，FScenePrimitiveInfo则是图元在渲染线程的状态表示，包含一个对应的FPrimitiveSceneProxy，其中会调用AddPrimitiveSceneInfo_RenderThread把Primitive加入到渲染线程中的一个数据结构中，留待渲染线程去更新。</p><p>​    上面说到了，StaticMesh的顶点数据都存在了RenderData中，这一步也会一起转移给FPrimitiveSceneProxy，参考构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::AddPrimitive</span><span class="params">(UPrimitiveComponent* Primitive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//... Addprimitive中的关键代码</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Create the primitive&#x27;s scene proxy.</span></span><br><span class="line">    FPrimitiveSceneProxy* PrimitiveSceneProxy = Primitive-&gt;<span class="built_in">CreateSceneProxy</span>();</span><br><span class="line">    Primitive-&gt;SceneProxy = PrimitiveSceneProxy;</span><br><span class="line">    <span class="keyword">if</span>(!PrimitiveSceneProxy)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// Primitives which don&#x27;t have a proxy are irrelevant to the scene manager.</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the primitive scene info.</span></span><br><span class="line">    FPrimitiveSceneInfo* PrimitiveSceneInfo = <span class="keyword">new</span> <span class="built_in">FPrimitiveSceneInfo</span>(Primitive, <span class="keyword">this</span>);</span><br><span class="line">    PrimitiveSceneProxy-&gt;PrimitiveSceneInfo = PrimitiveSceneInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the primitives initial transform.</span></span><br><span class="line">    FMatrix RenderMatrix = Primitive-&gt;<span class="built_in">GetRenderMatrix</span>();</span><br><span class="line">    <span class="function">FVector <span class="title">AttachmentRootPosition</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    AActor* AttachmentRoot = Primitive-&gt;<span class="built_in">GetAttachmentRootActor</span>();</span><br><span class="line">    <span class="keyword">if</span> (AttachmentRoot)</span><br><span class="line">    &#123;</span><br><span class="line">       AttachmentRootPosition = AttachmentRoot-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FCreateRenderThreadParameters</span></span><br><span class="line">    &#123;</span><br><span class="line">       FPrimitiveSceneProxy* PrimitiveSceneProxy;</span><br><span class="line">       FMatrix RenderMatrix;</span><br><span class="line">       FBoxSphereBounds WorldBounds;</span><br><span class="line">       FVector AttachmentRootPosition;</span><br><span class="line">       FBoxSphereBounds LocalBounds;</span><br><span class="line">    &#125;;</span><br><span class="line">    FCreateRenderThreadParameters Params =</span><br><span class="line">    &#123;</span><br><span class="line">       PrimitiveSceneProxy,</span><br><span class="line">       RenderMatrix,</span><br><span class="line">       Primitive-&gt;Bounds,</span><br><span class="line">       AttachmentRootPosition,</span><br><span class="line">       Primitive-&gt;<span class="built_in">CalcBounds</span>(FTransform::Identity)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create any RenderThreadResources required and send a command to the rendering thread to add the primitive to the scene.</span></span><br><span class="line">    FScene* Scene = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this primitive has a simulated previous transform, ensure that the velocity data for the scene representation is correct</span></span><br><span class="line">    TOptional&lt;FTransform&gt; PreviousTransform = FMotionVectorSimulation::<span class="built_in">Get</span>().<span class="built_in">GetPreviousTransform</span>(Primitive);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ENQUEUE_RENDER_COMMAND</span>(AddPrimitiveCommand)(</span><br><span class="line">       [Params = <span class="built_in">MoveTemp</span>(Params), Scene, PrimitiveSceneInfo, PreviousTransform = <span class="built_in">MoveTemp</span>(PreviousTransform)](FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">       &#123;</span><br><span class="line">          FPrimitiveSceneProxy* SceneProxy = Params.PrimitiveSceneProxy;</span><br><span class="line">          FScopeCycleCounter <span class="built_in">Context</span>(SceneProxy-&gt;<span class="built_in">GetStatId</span>());</span><br><span class="line">          SceneProxy-&gt;<span class="built_in">SetTransform</span>(Params.RenderMatrix, Params.WorldBounds, Params.LocalBounds, Params.AttachmentRootPosition);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create any RenderThreadResources required.</span></span><br><span class="line">          SceneProxy-&gt;<span class="built_in">CreateRenderThreadResources</span>();</span><br><span class="line"></span><br><span class="line">          Scene-&gt;<span class="built_in">AddPrimitiveSceneInfo_RenderThread</span>(PrimitiveSceneInfo, PreviousTransform);</span><br><span class="line">       &#125;);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::AddPrimitiveSceneInfo_RenderThread</span><span class="params">(FPrimitiveSceneInfo* PrimitiveSceneInfo, <span class="type">const</span> TOptional&lt;FTransform&gt;&amp; PreviousTransform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">check</span>(<span class="built_in">IsInRenderingThread</span>());</span><br><span class="line"><span class="built_in">check</span>(PrimitiveSceneInfo-&gt;PackedIndex == INDEX_NONE);</span><br><span class="line"><span class="built_in">check</span>(!AddedPrimitiveSceneInfos.<span class="built_in">Contains</span>(PrimitiveSceneInfo));</span><br><span class="line">AddedPrimitiveSceneInfos.<span class="built_in">Add</span>(PrimitiveSceneInfo);</span><br><span class="line"><span class="keyword">if</span> (PreviousTransform.<span class="built_in">IsSet</span>())</span><br><span class="line">&#123;</span><br><span class="line">OverridenPreviousTransforms.<span class="built_in">Add</span>(PrimitiveSceneInfo, PreviousTransform.<span class="built_in">GetValue</span>().<span class="built_in">ToMatrixWithScale</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    接下来就是在渲染线程更新这些PrimitiveSceneInfo数据，具体调用接口在FScene::UpdateAllPrimitiveSceneInfos，这个函数总共包含500+行的代码，我们可以分块看它的主体实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FScene::UpdateAllPrimitiveSceneInfos</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, <span class="type">bool</span> bAsyncCreateLPIs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理场景中移除的图元</span></span><br><span class="line">    <span class="keyword">while</span> (RemovedLocalPrimitiveSceneInfos.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理场景中增加的图元</span></span><br><span class="line">    <span class="keyword">while</span> (AddedLocalPrimitiveSceneInfos.<span class="built_in">Num</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理场景中更新的图元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; Transform : UpdatedTransforms)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理其他数据 比如距离场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The following arrays are densely packed primitive data needed by various</span></span><br><span class="line"><span class="comment"> * rendering passes. PrimitiveSceneInfo-&gt;PackedIndex maintains the index</span></span><br><span class="line"><span class="comment"> * where data is stored in these arrays for a given primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Packed array of primitives in the scene. */</span></span><br><span class="line">TArray&lt;FPrimitiveSceneInfo*&gt; Primitives;</span><br><span class="line"><span class="comment">/** Packed array of all transforms in the scene. */</span></span><br><span class="line">TArray&lt;FMatrix&gt; PrimitiveTransforms;</span><br><span class="line"><span class="comment">/** Packed array of primitive scene proxies in the scene. */</span></span><br><span class="line">TArray&lt;FPrimitiveSceneProxy*&gt; PrimitiveSceneProxies;</span><br><span class="line"><span class="comment">/** Packed array of primitive bounds. */</span></span><br><span class="line">TArray&lt;FPrimitiveBounds&gt; PrimitiveBounds;</span><br><span class="line"><span class="comment">/** Packed array of primitive flags. */</span></span><br><span class="line">TArray&lt;FPrimitiveFlagsCompact&gt; PrimitiveFlagsCompact;</span><br><span class="line"><span class="comment">/** Packed array of precomputed primitive visibility IDs. */</span></span><br><span class="line">TArray&lt;FPrimitiveVisibilityId&gt; PrimitiveVisibilityIds;</span><br><span class="line"><span class="comment">/** Packed array of primitive occlusion flags. See EOcclusionFlags. */</span></span><br><span class="line">TArray&lt;uint8&gt; PrimitiveOcclusionFlags;</span><br><span class="line"><span class="comment">/** Packed array of primitive occlusion bounds. */</span></span><br><span class="line">TArray&lt;FBoxSphereBounds&gt; PrimitiveOcclusionBounds;</span><br><span class="line"><span class="comment">/** Packed array of primitive components associated with the primitive. */</span></span><br><span class="line">TArray&lt;FPrimitiveComponentId&gt; PrimitiveComponentIds;</span><br><span class="line"><span class="comment">/** Packed array of runtime virtual texture flags. */</span></span><br><span class="line">TArray&lt;FPrimitiveVirtualTextureFlags&gt; PrimitiveVirtualTextureFlags;</span><br><span class="line"><span class="comment">/** Packed array of runtime virtual texture lod info. */</span></span><br><span class="line">TArray&lt;FPrimitiveVirtualTextureLodInfo&gt; PrimitiveVirtualTextureLod;</span><br></pre></td></tr></table></figure><p>​    在处理不同图元的时候，主要是通过更新FScene中的各种数组成员，UE把FPrimitiveSceneProxy按照类型排序存储在数组中，并且在添加和移除时通过更新TypeOffsetTable来快速交换位置，以达到减少数组内数据位置移动带来的消耗。</p><h2 id="SceneProxy-gt-MeshBatch"><a href="#SceneProxy-gt-MeshBatch" class="headerlink" title="SceneProxy-&gt;MeshBatch"></a>SceneProxy-&gt;MeshBatch</h2><p>把数据赋值给了FPrimitiveSceneInfo之后，我们 就要在渲染线程对其进行整合生成MeshBatch。MeshBatch是一组拥有相同材质，顶点数据的Mesh组合，下面是处理流程图：</p><p><img src="/2024/06/18/renderworkflow_data/workflow_addstaticmesh.png" alt></p><p>​    在更新场景时，会调用FPrimitiveSceneInfo::AddToScene来把数据真正传递给渲染线程，通过SCOPE事件，我们大概能看出每一部分在做什么，比如更新Lightmap，Bounds等等，我们这里关注AddStaticMeshes的调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::AddToScene</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos, <span class="type">bool</span> bUpdateStaticDrawLists, <span class="type">bool</span> bAddToStaticDrawLists, <span class="type">bool</span> bAsyncCreateLPIs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="built_in">IsInRenderingThread</span>());</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_IndirectLightingCacheUniformBuffer, FColor::Turquoise);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_IndirectLightingCacheAllocation, FColor::Orange);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_LightmapDataOffset, FColor::Green);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_ReflectionCaptures, FColor::Yellow);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_AddStaticMeshes, FColor::Magenta);</span><br><span class="line">       <span class="keyword">if</span> (bUpdateStaticDrawLists)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">AddStaticMeshes</span>(RHICmdList, Scene, SceneInfos, bAddToStaticDrawLists);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_AddToPrimitiveOctree, FColor::Red);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_UpdateBounds, FColor::Cyan);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddToScene_UpdateVirtualTexture, FColor::Emerald);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在AddStaticMeshes中，主要做了三步，首先DrawStaticElements填充PrimitiveSceneInfo的MeshBatch数据，然后把MeshBatch数据转移到Scene的StaticMeshes数组中，统一管理，然后缓存MeshDrawCommands。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::AddStaticMeshes</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos, <span class="type">bool</span> bAddToStaticDrawLists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LLM_SCOPE</span>(ELLMTag::StaticMesh);</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">ParallelForTemplate</span>(SceneInfos.<span class="built_in">Num</span>(), [Scene, &amp;SceneInfos](int32 Index)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddStaticMeshes_DrawStaticElements, FColor::Magenta);</span><br><span class="line">          FPrimitiveSceneInfo* SceneInfo = SceneInfos[Index];</span><br><span class="line">          <span class="comment">// Cache the primitive&#x27;s static mesh elements.</span></span><br><span class="line">          FBatchingSPDI <span class="built_in">BatchingSPDI</span>(SceneInfo);</span><br><span class="line">          BatchingSPDI.<span class="built_in">SetHitProxy</span>(SceneInfo-&gt;DefaultDynamicHitProxy);</span><br><span class="line">           <span class="comment">//创建MeshBatch</span></span><br><span class="line">          SceneInfo-&gt;Proxy-&gt;<span class="built_in">DrawStaticElements</span>(&amp;BatchingSPDI);</span><br><span class="line">          SceneInfo-&gt;StaticMeshes.<span class="built_in">Shrink</span>();</span><br><span class="line">          SceneInfo-&gt;StaticMeshRelevances.<span class="built_in">Shrink</span>();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">check</span>(SceneInfo-&gt;StaticMeshRelevances.<span class="built_in">Num</span>() == SceneInfo-&gt;StaticMeshes.<span class="built_in">Num</span>());</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">SCOPED_NAMED_EVENT</span>(FPrimitiveSceneInfo_AddStaticMeshes_UpdateSceneArrays, FColor::Blue);</span><br><span class="line">       <span class="keyword">for</span> (FPrimitiveSceneInfo* SceneInfo : SceneInfos)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">for</span> (int32 MeshIndex = <span class="number">0</span>; MeshIndex &lt; SceneInfo-&gt;StaticMeshes.<span class="built_in">Num</span>(); MeshIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">             FStaticMeshBatchRelevance&amp; MeshRelevance = SceneInfo-&gt;StaticMeshRelevances[MeshIndex];</span><br><span class="line">             FStaticMeshBatch&amp; Mesh = SceneInfo-&gt;StaticMeshes[MeshIndex];</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Add the static mesh to the scene&#x27;s static mesh list.</span></span><br><span class="line">             FSparseArrayAllocationInfo SceneArrayAllocation = Scene-&gt;StaticMeshes.<span class="built_in">AddUninitialized</span>();</span><br><span class="line">             Scene-&gt;StaticMeshes[SceneArrayAllocation.Index] = &amp;Mesh;</span><br><span class="line">             Mesh.Id = SceneArrayAllocation.Index;</span><br><span class="line">             MeshRelevance.Id = SceneArrayAllocation.Index;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bAddToStaticDrawLists)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">CacheMeshDrawCommands</span>(RHICmdList, Scene, SceneInfos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DrawStaticElements"><a href="#DrawStaticElements" class="headerlink" title="DrawStaticElements"></a>DrawStaticElements</h3><p>我们接着看第一步具体做了什么FStaticMeshSceneProxy::DrawStaticElements，这里只关注主体分支的调用，其他一些特殊情况的分支实现基本相同，比如当指定ForcedLodModel时，我们只对指定LOD的Mesh数据创建MeshBatch。这里主要调用了两个接口填充MeshBatch，GetMeshElement和DrawMeshes，其中GetMeshElement主要负责把VF，LOD，Material相关数据从staticmesh的数据结构中存储到Meshbatch，而drawmeshes负责把meshbatch数据存储到FPrimitiveSceneInfo的StaticMeshes数组中，此外还额外存储了StaticMeshRelevances（与StaticMesh相同，存储了一些其他信息，但为了效率需要特殊处理，后续会提到）。到这一步就完成了渲染数据从场景中的StaticMesh转移到了渲染线程中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FStaticMeshSceneProxy::DrawStaticElements</span><span class="params">(FStaticPrimitiveDrawInterface* PDI)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// Draw the static mesh elements.</span></span><br><span class="line">             <span class="keyword">for</span>(int32 SectionIndex = <span class="number">0</span>;SectionIndex &lt; LODModel.Sections.<span class="built_in">Num</span>();SectionIndex++)</span><br><span class="line">             &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_EDITOR</span></span><br><span class="line">                <span class="keyword">if</span>( GIsEditor )</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="type">const</span> FLODInfo::FSectionInfo&amp; Section = LODs[LODIndex].Sections[SectionIndex];</span><br><span class="line"></span><br><span class="line">                   bIsMeshElementSelected = Section.bSelected;</span><br><span class="line">                   PDI-&gt;<span class="built_in">SetHitProxy</span>(Section.HitProxy);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WITH_EDITOR</span></span></span><br><span class="line"></span><br><span class="line">                <span class="type">const</span> int32 NumBatches = <span class="built_in">GetNumMeshBatches</span>();</span><br><span class="line">                PDI-&gt;<span class="built_in">ReserveMemoryForMeshes</span>(NumBatches * (<span class="number">1</span> + NumRuntimeVirtualTextureTypes));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (int32 BatchIndex = <span class="number">0</span>; BatchIndex &lt; NumBatches; BatchIndex++)</span><br><span class="line">                &#123;</span><br><span class="line">                   FMeshBatch BaseMeshBatch;</span><br><span class="line">                   <span class="keyword">if</span> (<span class="built_in">GetMeshElement</span>(LODIndex, BatchIndex, SectionIndex, PrimitiveDPG, bIsMeshElementSelected, <span class="literal">true</span>, BaseMeshBatch))</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="keyword">if</span> (NumRuntimeVirtualTextureTypes &gt; <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                         <span class="comment">// Runtime virtual texture mesh elements.</span></span><br><span class="line">                         <span class="function">FMeshBatch <span class="title">MeshBatch</span><span class="params">(BaseMeshBatch)</span></span>;</span><br><span class="line">                         <span class="built_in">SetupMeshBatchForRuntimeVirtualTexture</span>(MeshBatch);</span><br><span class="line"></span><br><span class="line">                         <span class="keyword">for</span> (ERuntimeVirtualTextureMaterialType MaterialType : RuntimeVirtualTextureMaterialTypes)</span><br><span class="line">                         &#123;</span><br><span class="line">                            MeshBatch.RuntimeVirtualTextureMaterialType = (uint32)MaterialType;</span><br><span class="line">                            PDI-&gt;<span class="built_in">DrawMesh</span>(MeshBatch, ScreenSize);</span><br><span class="line">                         &#125;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      &#123;</span><br><span class="line">                         <span class="comment">// Standard mesh elements.</span></span><br><span class="line">                         <span class="comment">// If we have submitted an optimized shadow-only mesh, remaining mesh elements must not cast shadows.</span></span><br><span class="line">                         <span class="function">FMeshBatch <span class="title">MeshBatch</span><span class="params">(BaseMeshBatch)</span></span>;</span><br><span class="line">                         MeshBatch.CastShadow &amp;= !bUseUnifiedMeshForShadow;</span><br><span class="line">                         MeshBatch.bUseAsOccluder &amp;= !bUseUnifiedMeshForDepth;</span><br><span class="line">                         MeshBatch.bUseForDepthPass &amp;= !bUseUnifiedMeshForDepth;</span><br><span class="line">                         PDI-&gt;<span class="built_in">DrawMesh</span>(MeshBatch, ScreenSize);</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MeshBatch-gt-MeshDrawCommands"><a href="#MeshBatch-gt-MeshDrawCommands" class="headerlink" title="MeshBatch-&gt;MeshDrawCommands"></a>MeshBatch-&gt;MeshDrawCommands</h2><p>MeshDrawCommands是由MeshBatch生成，最终会交给RHI线程的一组渲染命令，包含渲染关系状态，Shader绑定状态，Mesh信息等等。</p><p>FMeshPassProcessor是一个将MeshBatch转换成MeshDrawCommands的工具类，有多种Pass子类实现。</p><p>注意：这里因为是处理StaticMesh，所以最终MeshDrawCommands会存储到CachedDrawCommands中</p><h3 id="CacheMeshDrawCommands"><a href="#CacheMeshDrawCommands" class="headerlink" title="CacheMeshDrawCommands"></a>CacheMeshDrawCommands</h3><p>​    这一步做的事情很多，主要是缓存对应的MeshDrawCommands，在后面的工作流中也会用到这里的结果。看代码可以发现主要是通过多线程执行对应的lambda，首先预创建StaticMeshCommandInfos数据结构，大小等于Meshbatch*MeshPassNum，然后通过PassMeshProcessor创建对应的MeshDrawCommands，并填充StaticMeshCommandInfos数据结构，这个结构在后面标记相关性时会用到。下面截取CacheMeshDrawCommands的主要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FPrimitiveSceneInfo::CacheMeshDrawCommands</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList, FScene* Scene, <span class="type">const</span> TArrayView&lt;FPrimitiveSceneInfo*&gt;&amp; SceneInfos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...预创建StaticMeshCommandInfos</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> DoWorkLambda = [Scene, SceneInfos](int32 Index)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span> (int32 PassIndex = <span class="number">0</span>; PassIndex &lt; EMeshPass::Num; PassIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> EShadingPath ShadingPath = Scene-&gt;<span class="built_in">GetShadingPath</span>();</span><br><span class="line">          EMeshPass::Type PassType = (EMeshPass::Type)PassIndex;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ((FPassProcessorManager::<span class="built_in">GetPassFlags</span>(ShadingPath, PassType) &amp; EMeshPassFlags::CachedMeshCommands) != EMeshPassFlags::None)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="function">FCachedMeshDrawCommandInfo <span class="title">CommandInfo</span><span class="params">(PassType)</span></span>;</span><br><span class="line"></span><br><span class="line">             FCriticalSection&amp; CachedMeshDrawCommandLock = Scene-&gt;CachedMeshDrawCommandLock[PassType];</span><br><span class="line">             FCachedPassMeshDrawList&amp; SceneDrawList = Scene-&gt;CachedDrawLists[PassType];</span><br><span class="line">             FStateBucketMap&amp; CachedMeshDrawCommandStateBuckets = Scene-&gt;CachedMeshDrawCommandStateBuckets[PassType];</span><br><span class="line">              <span class="comment">//将CommandInfo传入context，MeshDrawCommands最后会填充这个结构</span></span><br><span class="line">             <span class="function">FCachedPassMeshDrawListContext <span class="title">CachedPassMeshDrawListContext</span><span class="params">(CommandInfo, CachedMeshDrawCommandLock, SceneDrawList, CachedMeshDrawCommandStateBuckets, *Scene)</span></span>;</span><br><span class="line"><span class="comment">//这里拿到MeshProcessor创建函数</span></span><br><span class="line">             PassProcessorCreateFunction CreateFunction = FPassProcessorManager::<span class="built_in">GetCreateFunction</span>(ShadingPath, PassType);</span><br><span class="line">             <span class="comment">//获得具体的Processor</span></span><br><span class="line">              FMeshPassProcessor* PassMeshProcessor = <span class="built_in">CreateFunction</span>(Scene, <span class="literal">nullptr</span>, &amp;CachedPassMeshDrawListContext);</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (PassMeshProcessor != <span class="literal">nullptr</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> FMeshInfoAndIndex&amp; MeshAndInfo : MeshBatches)</span><br><span class="line">                &#123;</span><br><span class="line">                   FPrimitiveSceneInfo* SceneInfo = SceneInfos[MeshAndInfo.InfoIndex];</span><br><span class="line">                   FStaticMeshBatch&amp; Mesh = SceneInfo-&gt;StaticMeshes[MeshAndInfo.MeshIndex];</span><br><span class="line">                   </span><br><span class="line">                   CommandInfo = <span class="built_in">FCachedMeshDrawCommandInfo</span>(PassType);</span><br><span class="line">                   FStaticMeshBatchRelevance&amp; MeshRelevance = SceneInfo-&gt;StaticMeshRelevances[MeshAndInfo.MeshIndex];</span><br><span class="line"></span><br><span class="line">                   <span class="built_in">check</span>(!MeshRelevance.CommandInfosMask.<span class="built_in">Get</span>(PassType));</span><br><span class="line"></span><br><span class="line">                   uint64 BatchElementMask = ~<span class="number">0ull</span>;</span><br><span class="line">                    <span class="comment">//添加对应的Meshbatch，并生成MeshDrawCommands，这里</span></span><br><span class="line">                   PassMeshProcessor-&gt;<span class="built_in">AddMeshBatch</span>(Mesh, BatchElementMask, SceneInfo-&gt;Proxy);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (CommandInfo.CommandIndex != <span class="number">-1</span> || CommandInfo.StateBucketId != <span class="number">-1</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                      <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(MeshRelevance.CommandInfosMask) * <span class="number">8</span> &gt;= EMeshPass::Num, <span class="string">&quot;CommandInfosMask is too small to contain all mesh passes.&quot;</span>);</span><br><span class="line">                      MeshRelevance.CommandInfosMask.<span class="built_in">Set</span>(PassType);</span><br><span class="line">                      MeshRelevance.CommandInfosBase++;</span><br><span class="line"></span><br><span class="line">                      <span class="type">int</span> CommandInfoIndex = MeshAndInfo.MeshIndex * EMeshPass::Num + PassType;</span><br><span class="line">                      <span class="built_in">check</span>(SceneInfo-&gt;StaticMeshCommandInfos[CommandInfoIndex].MeshPass == EMeshPass::Num);</span><br><span class="line">                       <span class="comment">//填充StaticMeshCommandInfos数据结构</span></span><br><span class="line">                      SceneInfo-&gt;StaticMeshCommandInfos[CommandInfoIndex] = CommandInfo;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                PassMeshProcessor-&gt;~<span class="built_in">FMeshPassProcessor</span>();</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后续其他处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    我们接着看AddMeshBatch是如何生成MeshDrawCommands的，内部调用了TryAddMeshBatch，然后通过对应Processor的Process接口调用BuildMeshDrawCommands最终生MeshDrawCommands。</p><p>BuildMeshDrawCommands这里会设置对应的材质shader，管线状态，以及VF声明。最后调用FinalizeCommand接口填充GPUScene用来合批的StateBuckets，以及把MeshDrawCommands放入Scene-&gt;CachedDrawLists[PassType]中，并把对应下标赋值给最开始传入Processsor的context的CommandInfo，也就是PrimitiveInfo中StaticMeshCommandInfos要赋值的对象。</p><p>这里涉及的函数太多就不展开了，总之我们知道这一步生成了MeshDrawCommands，并且存在了TaskContext的成员中，并且primitivesceneInfo中保存了对应的下标，这里TaskContext的保存MeshDrawCommands的成员就是最开始创建Processor中指定的Drawlist，也就是上面代码中的Scene-&gt;CachedDrawLists。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;UE渲染工作流-一-——数据篇&quot;&gt;&lt;a href=&quot;#UE渲染工作流-一-——数据篇&quot; class=&quot;headerlink&quot; title=&quot;UE渲染工作流(一)——数据篇&quot;&gt;&lt;/a&gt;UE渲染工作流(一)——数据篇&lt;/h1&gt;&lt;p&gt;​    UE的渲染工作流基于原生API做了非常多的优化和封装，需要经常查阅和回顾这些工作流和数据结构，才能理解其中的奥妙。本篇内容要讨论的是数据准备篇，主要包含一个StaticMesh被放入场景中后，它的渲染数据是如何被整理应用的。注意：本篇只讲UE的部分工作流程，对于其中某个模块的具体算法实现细节不会不过解读，需要额外查阅资料，如果有时间，笔者会尽量记录在之后的文章中。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE源码" scheme="https://ritchielambda.github.io/tags/UE%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>GPUScene</title>
    <link href="https://ritchielambda.github.io/2024/06/13/GPUScene/"/>
    <id>https://ritchielambda.github.io/2024/06/13/GPUScene/</id>
    <published>2024-06-13T21:49:00.000Z</published>
    <updated>2025-02-20T14:21:17.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPUScene"><a href="#GPUScene" class="headerlink" title="GPUScene"></a>GPUScene</h1><p>GPUScene是UE用来实例化渲染的代码手段，想象场景中包含了数十上百个一样的物体，他们的材质，顶点信息都一样，不同的是他们的位置，缩放等不同，那么我们是否可以通过一个drawcall，来渲染这一批看起来是一个模板的物体，DX和OpenGL都提供了对应的API，我们统称为实例化渲染，本章主要是讲UE是怎么封装这些API，实现自动合批的。</p><span id="more"></span><p>要搞明白上面的问题，我们首先需要知道我们需要哪些信息，才能实现自动合批？首先我们需要知道哪些物体是可以合批的，因为UE是通过Meshdrawcommands来提交绘制的，所以我们需要把同批次的Meshdrawcommands合并，然后在提交绘制时选择对应的实例化绘制API，最终在shader中根据实例化id获取当前实例的数据(如变换矩阵等)来进行渲染。</p><p>UE的做法基本和我们需要的一致，流程如下：</p><h2 id="收集同批次的Meshdrawcommands"><a href="#收集同批次的Meshdrawcommands" class="headerlink" title="收集同批次的Meshdrawcommands"></a>收集同批次的Meshdrawcommands</h2><p>UE的静态绘制路径会生成对应的MeshDrawcommands，调用函数如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCachedPassMeshDrawListContext::FinalizeCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshBatch&amp; MeshBatch, </span></span></span><br><span class="line"><span class="params"><span class="function">    int32 BatchElementIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 DrawPrimitiveId,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 ScenePrimitiveId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerFillMode MeshFillMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerCullMode MeshCullMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommandSortKey SortKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FGraphicsMinimalPipelineStateInitializer&amp; PipelineState,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshProcessorShaders* ShadersForDebugging,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommand&amp; MeshDrawCommand)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FGraphicsMinimalPipelineStateId PipelineId = FGraphicsMinimalPipelineStateId::<span class="built_in">GetPersistentId</span>(PipelineState);</span><br><span class="line"></span><br><span class="line">    MeshDrawCommand.<span class="built_in">SetDrawParametersAndFinalize</span>(MeshBatch, BatchElementIndex, PipelineId, ShadersForDebugging);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UseGPUScene</span>(GMaxRHIShaderPlatform, GMaxRHIFeatureLevel))</span><br><span class="line">       &#123;</span><br><span class="line">       Experimental::FHashElementId SetId;</span><br><span class="line">       <span class="keyword">auto</span> hash = CachedMeshDrawCommandStateBuckets.<span class="built_in">ComputeHash</span>(MeshDrawCommand);</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="function">FScopeLock <span class="title">Lock</span><span class="params">(&amp;CachedMeshDrawCommandLock)</span></span>;</span><br><span class="line">          SetId = CachedMeshDrawCommandStateBuckets.<span class="built_in">FindOrAddIdByHash</span>(hash, MeshDrawCommand, <span class="built_in">FMeshDrawCommandCount</span>());</span><br><span class="line">          .<span class="built_in">GetByElementId</span>(SetId).Value.Num++;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MESH_DRAW_COMMAND_DEBUG_DATA</span></span><br><span class="line">          <span class="keyword">if</span> (CachedMeshDrawCommandStateBuckets.<span class="built_in">GetByElementId</span>(SetId).Value.Num == <span class="number">1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">          MeshDrawCommand.<span class="built_in">ClearDebugPrimitiveSceneProxy</span>(); <span class="comment">//When using State Buckets multiple PrimitiveSceneProxies use the same MeshDrawCommand, so The PrimitiveSceneProxy pointer can&#x27;t be stored.</span></span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">check</span>(CommandInfo.StateBucketId == <span class="number">-1</span>);</span><br><span class="line">       CommandInfo.StateBucketId = SetId.<span class="built_in">GetIndex</span>();</span><br><span class="line">       <span class="built_in">check</span>(CommandInfo.CommandIndex == <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到这里用了一个比较关键的数据结构：CachedMeshDrawCommandStateBuckets，key是meshdrawcommands的hash。</p><p>看代码可以发现，Buckets的模板参数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FStateBucketMap = Experimental::TRobinHoodHashMap&lt;FMeshDrawCommand, FMeshDrawCommandCount, MeshDrawCommandKeyFuncs&gt;;</span><br></pre></td></tr></table></figure><p>上面的ComputeHash最终调用MeshDrawCommandKeyFuncs内的实现：GetDynamicInstancingHash，传入当前MeshdrawCommands的VertexBuffer，VertexStream等等决定合批的因素。</p><p>FindOrAddIdByHash最终调用MeshDrawCommandKeyFuncs内的Matches，也就是MeshDrawCommands的MatchesForDynamicInstancing，这里就是决定是否可以合批的判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MatchesForDynamicInstancing</span><span class="params">(<span class="type">const</span> FMeshDrawCommand&amp; Rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CachedPipelineId == Rhs.CachedPipelineId</span><br><span class="line">       &amp;&amp; StencilRef == Rhs.StencilRef</span><br><span class="line">       &amp;&amp; ShaderBindings.<span class="built_in">MatchesForDynamicInstancing</span>(Rhs.ShaderBindings)</span><br><span class="line">       &amp;&amp; VertexStreams == Rhs.VertexStreams</span><br><span class="line">       &amp;&amp; PrimitiveIdStreamIndex == Rhs.PrimitiveIdStreamIndex</span><br><span class="line">       &amp;&amp; IndexBuffer == Rhs.IndexBuffer</span><br><span class="line">       &amp;&amp; FirstIndex == Rhs.FirstIndex</span><br><span class="line">       &amp;&amp; NumPrimitives == Rhs.NumPrimitives</span><br><span class="line">       &amp;&amp; NumInstances == Rhs.NumInstances</span><br><span class="line">       &amp;&amp; ((NumPrimitives &gt; <span class="number">0</span> &amp;&amp; VertexParams.BaseVertexIndex == Rhs.VertexParams.BaseVertexIndex &amp;&amp; VertexParams.NumVertices == Rhs.VertexParams.NumVertices)</span><br><span class="line">          || (NumPrimitives == <span class="number">0</span> &amp;&amp; IndirectArgs.Buffer == Rhs.IndirectArgs.Buffer &amp;&amp; IndirectArgs.Offset == Rhs.IndirectArgs.Offset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断具有合批条件的MeshDrawCommands，会被塞入CachedMeshDrawCommandStateBuckets同一个hash地址中，并且计数会加一。</p><h2 id="执行MeshDrawCommands合并"><a href="#执行MeshDrawCommands合并" class="headerlink" title="执行MeshDrawCommands合并"></a>执行MeshDrawCommands合并</h2><h3 id="合并Meshdrawcommands"><a href="#合并Meshdrawcommands" class="headerlink" title="合并Meshdrawcommands"></a>合并Meshdrawcommands</h3><p>上面已经将可以合并的MeshDrawCommands做了统计，放在Buckets中，然而我们渲染要执行的MeshDrawCommands数量并没有减少，接下来我们就需要对MeshDrawCommands进行真正的合并，入口在：BuildMeshDrawCommandPrimitiveIdBuffer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMeshDrawCommandPrimitiveIdBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> bDynamicInstancing,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; VisibleMeshDrawCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    FDynamicMeshDrawCommandStorage&amp; MeshDrawCommandStorage,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* RESTRICT PrimitiveIdData,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32 PrimitiveIdDataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshCommandOneFrameArray&amp; TempVisibleMeshDrawCommands,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; MaxInstances,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; VisibleMeshDrawCommandsNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    int32&amp; NewPassVisibleMeshDrawCommandsNum,</span></span></span><br><span class="line"><span class="params"><span class="function">    EShaderPlatform ShaderPlatform,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 InstanceFactor = <span class="number">1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_BuildMeshDrawCommandPrimitiveIdBuffer);</span><br><span class="line">    <span class="built_in">check</span>(PrimitiveIdData &amp;&amp; PrimitiveIdDataSize &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FVisibleMeshDrawCommand* RESTRICT PassVisibleMeshDrawCommands = VisibleMeshDrawCommands.<span class="built_in">GetData</span>();</span><br><span class="line">    <span class="type">const</span> int32 NumDrawCommands = VisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">    uint32 PrimitiveIdIndex = <span class="number">0</span>;</span><br><span class="line">    int32* RESTRICT PrimitiveIds = (int32*)PrimitiveIdData;</span><br><span class="line">    <span class="type">const</span> uint32 MaxPrimitiveId = PrimitiveIdDataSize / <span class="built_in">sizeof</span>(int32);</span><br><span class="line"><span class="comment">//动态合批</span></span><br><span class="line">    <span class="keyword">if</span> (bDynamicInstancing)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_DynamicInstancingOfVisibleMeshDrawCommands);</span><br><span class="line">       <span class="built_in">check</span>(VisibleMeshDrawCommands.<span class="built_in">Num</span>() &lt;= TempVisibleMeshDrawCommands.<span class="built_in">Max</span>() &amp;&amp; TempVisibleMeshDrawCommands.<span class="built_in">Num</span>() == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       int32 CurrentStateBucketId = <span class="number">-1</span>;</span><br><span class="line">       uint32* RESTRICT CurrentDynamicallyInstancedMeshCommandNumInstances = <span class="literal">nullptr</span>;</span><br><span class="line">       MaxInstances = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 DrawCommandIndex = <span class="number">0</span>; DrawCommandIndex &lt; NumDrawCommands; DrawCommandIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FVisibleMeshDrawCommand&amp; RESTRICT VisibleMeshDrawCommand = PassVisibleMeshDrawCommands[DrawCommandIndex];</span><br><span class="line"><span class="comment">//如果遇到和上一个可以合批的commands</span></span><br><span class="line">          <span class="keyword">if</span> (VisibleMeshDrawCommand.StateBucketId == CurrentStateBucketId &amp;&amp; VisibleMeshDrawCommand.StateBucketId != <span class="number">-1</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//有Meshdrawcommandsinstance计数，直接加一</span></span><br><span class="line">             <span class="keyword">if</span> (CurrentDynamicallyInstancedMeshCommandNumInstances)</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="type">const</span> int32 CurrentNumInstances = *CurrentDynamicallyInstancedMeshCommandNumInstances;</span><br><span class="line">                *CurrentDynamicallyInstancedMeshCommandNumInstances = CurrentNumInstances + <span class="number">1</span>;</span><br><span class="line">                MaxInstances = FMath::<span class="built_in">Max</span>(MaxInstances, CurrentNumInstances + <span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//没有的就直接把Commands拷贝进新数组</span></span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand = VisibleMeshDrawCommand;</span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">             <span class="comment">// First time state bucket setup</span></span><br><span class="line">             CurrentStateBucketId = VisibleMeshDrawCommand.StateBucketId;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (VisibleMeshDrawCommand.StateBucketId != INDEX_NONE</span><br><span class="line">                &amp;&amp; VisibleMeshDrawCommand.MeshDrawCommand-&gt;PrimitiveIdStreamIndex &gt;= <span class="number">0</span></span><br><span class="line">                &amp;&amp; VisibleMeshDrawCommand.MeshDrawCommand-&gt;NumInstances == <span class="number">1</span></span><br><span class="line">                <span class="comment">// Don&#x27;t create a new FMeshDrawCommand for the last command and make it safe for us to look at the next command</span></span><br><span class="line">                &amp;&amp; DrawCommandIndex + <span class="number">1</span> &lt; NumDrawCommands</span><br><span class="line">                <span class="comment">// Only create a new FMeshDrawCommand if more than one draw in the state bucket</span></span><br><span class="line">                &amp;&amp; CurrentStateBucketId == PassVisibleMeshDrawCommands[DrawCommandIndex + <span class="number">1</span>].StateBucketId)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//遇到实例数&gt;1，且不是倒数第二个的commands，创建新commands</span></span><br><span class="line">                <span class="type">const</span> int32 Index = MeshDrawCommandStorage.MeshDrawCommands.<span class="built_in">AddElement</span>(*VisibleMeshDrawCommand.MeshDrawCommand);</span><br><span class="line">                FMeshDrawCommand&amp; NewCommand = MeshDrawCommandStorage.MeshDrawCommands[Index];</span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand;</span><br><span class="line"></span><br><span class="line">                NewVisibleMeshDrawCommand.<span class="built_in">Setup</span>(</span><br><span class="line">                   &amp;NewCommand,</span><br><span class="line">                   VisibleMeshDrawCommand.DrawPrimitiveId,</span><br><span class="line">                   VisibleMeshDrawCommand.ScenePrimitiveId,</span><br><span class="line">                   VisibleMeshDrawCommand.StateBucketId,</span><br><span class="line">                   VisibleMeshDrawCommand.MeshFillMode,</span><br><span class="line">                   VisibleMeshDrawCommand.MeshCullMode,</span><br><span class="line">                   VisibleMeshDrawCommand.SortKey);</span><br><span class="line"></span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line"></span><br><span class="line">                CurrentDynamicallyInstancedMeshCommandNumInstances = &amp;NewCommand.NumInstances;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//直接拷贝commands</span></span><br><span class="line">                CurrentDynamicallyInstancedMeshCommandNumInstances = <span class="literal">nullptr</span>;</span><br><span class="line">                FVisibleMeshDrawCommand NewVisibleMeshDrawCommand = VisibleMeshDrawCommand;</span><br><span class="line">                NewVisibleMeshDrawCommand.PrimitiveIdBufferOffset = PrimitiveIdIndex;</span><br><span class="line">                TempVisibleMeshDrawCommands.<span class="built_in">Emplace</span>(<span class="built_in">MoveTemp</span>(NewVisibleMeshDrawCommand));</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//@todo - refactor into instance step rate in the RHI</span></span><br><span class="line">          <span class="keyword">for</span> (uint32 InstanceFactorIndex = <span class="number">0</span>; InstanceFactorIndex &lt; InstanceFactor; InstanceFactorIndex++, PrimitiveIdIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//填充primitiveid数组</span></span><br><span class="line">             <span class="comment">//@todo - refactor into memcpy</span></span><br><span class="line">             <span class="built_in">checkSlow</span>(PrimitiveIdIndex &lt; MaxPrimitiveId);</span><br><span class="line">             <span class="keyword">if</span> (!<span class="built_in">GPUSceneUseTexture2D</span>(ShaderPlatform))</span><br><span class="line">             &#123;</span><br><span class="line">                PrimitiveIds[PrimitiveIdIndex] = VisibleMeshDrawCommand.DrawPrimitiveId;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                <span class="comment">//Packing for mobile texture2D GPUScene. Must be in sync with SceneData.ush</span></span><br><span class="line">                uint16 PrimitivesPerTextureLine = FPrimitiveSceneShaderData::<span class="built_in">GetPrimitivesPerTextureLine</span>();</span><br><span class="line">                PrimitiveIds[PrimitiveIdIndex] = ((VisibleMeshDrawCommand.DrawPrimitiveId / PrimitivesPerTextureLine) &lt;&lt; <span class="number">16</span>) | (VisibleMeshDrawCommand.DrawPrimitiveId % PrimitivesPerTextureLine);</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Setup instancing stats for logging.</span></span><br><span class="line">       VisibleMeshDrawCommandsNum = VisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line">       NewPassVisibleMeshDrawCommandsNum = TempVisibleMeshDrawCommands.<span class="built_in">Num</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Replace VisibleMeshDrawCommands</span></span><br><span class="line">       FMemory::<span class="built_in">Memswap</span>(&amp;VisibleMeshDrawCommands, &amp;TempVisibleMeshDrawCommands, <span class="built_in">sizeof</span>(TempVisibleMeshDrawCommands));</span><br><span class="line">       TempVisibleMeshDrawCommands.<span class="built_in">Reset</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">QUICK_SCOPE_CYCLE_COUNTER</span>(STAT_BuildVisibleMeshDrawCommandPrimitiveIdBuffers);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 DrawCommandIndex = <span class="number">0</span>; DrawCommandIndex &lt; NumDrawCommands; DrawCommandIndex++)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="type">const</span> FVisibleMeshDrawCommand&amp; VisibleMeshDrawCommand = VisibleMeshDrawCommands[DrawCommandIndex];</span><br><span class="line">          <span class="keyword">for</span> (uint32 InstanceFactorIndex = <span class="number">0</span>; InstanceFactorIndex &lt; InstanceFactor; InstanceFactorIndex++, PrimitiveIdIndex++)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="built_in">checkSlow</span>(PrimitiveIdIndex &lt; MaxPrimitiveId);</span><br><span class="line">             PrimitiveIds[PrimitiveIdIndex] = VisibleMeshDrawCommand.DrawPrimitiveId;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这一步主要是合并meshdrawcommands，以及填充primitiveids数组，此数组最终会被填充到vertexfactory的vertexstream中，用来在shader中获取对应的primitivedata实例数据。数据传输顺序是：primitiveids是由FMeshDrawCommandPassSetupTask.Context.PrimitiveIdBufferData赋值，PrimitiveIdBufferData在FParallelMeshDrawCommandPass::DispatchDraw时会memcpy给PrimitiveIdsBuffer，最终PrimitiveIdsBuffer会被传给SubmitMeshDrawCommandsRange接口进行绘制，在接口中数据被赋值给VertexStream。</p><h3 id="设置meshdrawcommands的primitiveid数据"><a href="#设置meshdrawcommands的primitiveid数据" class="headerlink" title="设置meshdrawcommands的primitiveid数据"></a>设置meshdrawcommands的primitiveid数据</h3><p>下面截取部分SubmitDraw的实现，主要包含VertexStream赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int32 VertexBindingIndex = <span class="number">0</span>; VertexBindingIndex &lt; MeshDrawCommand.VertexStreams.<span class="built_in">Num</span>(); VertexBindingIndex++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> FVertexInputStream&amp; Stream = MeshDrawCommand.VertexStreams[VertexBindingIndex];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.PrimitiveIdStreamIndex != <span class="number">-1</span> &amp;&amp; Stream.StreamIndex == MeshDrawCommand.PrimitiveIdStreamIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里赋值给对应的Stream</span></span><br><span class="line">       RHICmdList.<span class="built_in">SetStreamSource</span>(Stream.StreamIndex, ScenePrimitiveIdsBuffer, PrimitiveIdOffset);</span><br><span class="line">       StateCache.VertexStreams[Stream.StreamIndex] = Stream;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StateCache.VertexStreams[Stream.StreamIndex] != Stream)</span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">SetStreamSource</span>(Stream.StreamIndex, Stream.VertexBuffer, Stream.Offset);</span><br><span class="line">       StateCache.VertexStreams[Stream.StreamIndex] = Stream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么可以通过MeshDrawCommand.PrimitiveIdStreamIndex来判断当前stream是否是primitiveid对应的Stream，原因是在buildmeshdrawcommands时就被赋值，可见UE的代码每一步都有它的用处，每到此刻会被它的设计巧妙所惊叹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMeshPassProcessor::BuildMeshDrawCommands</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    SharedMeshDrawCommand.PrimitiveIdStreamIndex = VertexFactory-&gt;<span class="built_in">GetPrimitiveIdStreamIndex</span>(InputStreamType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在顶点工厂数据被mesh填充时会执行下面的接口，预先创建instance需要的vertexstream：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLocalVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里的VertexStreamUsage指定为EVertexStreamUsage::Instancing，在寻址时，PrimitiveIdVertexStream就会是instance的寻址。</span></span><br><span class="line">StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">1</span>, InputStreamType));</span><br><span class="line">PrimitiveIdStreamIndex[TypeIndex] = StreamElements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行instance绘制"><a href="#执行instance绘制" class="headerlink" title="执行instance绘制"></a>执行instance绘制</h3><p>还是在submitdraw中，根据commands的NumPrimitives字段来调用不同的RHI的API，执行instance绘制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MeshDrawCommand.IndexBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawIndexedPrimitive</span>(</span><br><span class="line">          MeshDrawCommand.IndexBuffer,</span><br><span class="line">          MeshDrawCommand.VertexParams.BaseVertexIndex,</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          MeshDrawCommand.VertexParams.NumVertices,</span><br><span class="line">          MeshDrawCommand.FirstIndex,</span><br><span class="line">          MeshDrawCommand.NumPrimitives,</span><br><span class="line">          MeshDrawCommand.NumInstances * InstanceFactor</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawIndexedPrimitiveIndirect</span>(</span><br><span class="line">          MeshDrawCommand.IndexBuffer, </span><br><span class="line">          MeshDrawCommand.IndirectArgs.Buffer, </span><br><span class="line">          MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">          );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (MeshDrawCommand.NumPrimitives &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    RHICmdList.<span class="built_in">DrawPrimitive</span>(</span><br><span class="line">       MeshDrawCommand.VertexParams.BaseVertexIndex + MeshDrawCommand.FirstIndex,</span><br><span class="line">       MeshDrawCommand.NumPrimitives,</span><br><span class="line">          MeshDrawCommand.NumInstances * InstanceFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       RHICmdList.<span class="built_in">DrawPrimitiveIndirect</span>(</span><br><span class="line">          MeshDrawCommand.IndirectArgs.Buffer,</span><br><span class="line">          MeshDrawCommand.IndirectArgs.Offset</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在Shader中获取对应的instancedata"><a href="#在Shader中获取对应的instancedata" class="headerlink" title="在Shader中获取对应的instancedata"></a>在Shader中获取对应的instancedata</h3><p>​    在之前UE把了primitiveid数组填充进了vertexstream，对应的vertexstream是EVertexStreamUsage::Instancing类型的，也就是每个instance对应一个vertexstream中的数据，UE的顶点数据传入不是把所有的属性放在同一个buffer中传入，而是每个属性对应一个buffer，根据不同的vertexfactory，最终shader编译时include不同的ush文件，最终实现vertexfactory和shderinput的兼容。</p><p>​    Shader中获取instance数据对应scenedata.ush的接口FPrimitiveSceneData GetPrimitiveData(uint PrimitiveId)，其中primitiveid对应不同的vertexfactory中的input，以local为例子，primitiveid对应第13个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct FVertexFactoryInput</span><br><span class="line">&#123;</span><br><span class="line">    float4 Position   : ATTRIBUTE0;</span><br><span class="line"></span><br><span class="line">#if !MANUAL_VERTEX_FETCH</span><br><span class="line">    #if METAL_PROFILE</span><br><span class="line">       float3 TangentX   : ATTRIBUTE1;</span><br><span class="line">       // TangentZ.w contains sign of tangent basis determinant</span><br><span class="line">       float4 TangentZ   : ATTRIBUTE2;</span><br><span class="line"></span><br><span class="line">       float4 Color     : ATTRIBUTE3;</span><br><span class="line">    #else</span><br><span class="line">       half3  TangentX   : ATTRIBUTE1;</span><br><span class="line">       // TangentZ.w contains sign of tangent basis determinant</span><br><span class="line">       half4  TangentZ   : ATTRIBUTE2;</span><br><span class="line"></span><br><span class="line">       half4  Color     : ATTRIBUTE3;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if USE_INSTANCING &amp;&amp; !MANUAL_VERTEX_FETCH</span><br><span class="line">    float4 InstanceOrigin : ATTRIBUTE8;  // per-instance random in w </span><br><span class="line">    half4 InstanceTransform1 : ATTRIBUTE9;  // hitproxy.r + 256 * selected in .w</span><br><span class="line">    half4 InstanceTransform2 : ATTRIBUTE10; // hitproxy.g in .w</span><br><span class="line">    half4 InstanceTransform3 : ATTRIBUTE11; // hitproxy.b in .w</span><br><span class="line">    float4 InstanceLightmapAndShadowMapUVBias : ATTRIBUTE12; </span><br><span class="line">#endif //USE_INSTANCING</span><br><span class="line"></span><br><span class="line">#if VF_USE_PRIMITIVE_SCENE_DATA</span><br><span class="line">    uint PrimitiveId : ATTRIBUTE13;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    GetPimitiveData其中调用了LoadPrimitivePrimitiveSceneDataElement，其实就是把数组数据赋值给了对应在Cpp中定义的数据结构，所以cpp中的FPrimitiveUniformShaderParameters一定要和shader中的FPrimitiveSceneData一一对应，不然就会取错下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float4 LoadPrimitivePrimitiveSceneDataElement(FPrimitiveIndex PrimitiveIndex, uint ItemIndex)</span><br><span class="line">&#123;</span><br><span class="line">#if VF_GPU_SCENE_TEXTURE</span><br><span class="line">    return View.PrimitiveSceneDataTexture.Load(int3(PrimitiveIndex.IndX + ItemIndex, PrimitiveIndex.IndY, 0));</span><br><span class="line">#else // !VF_GPU_SCENE_TEXTURE</span><br><span class="line">    return View.PrimitiveSceneData[PrimitiveIndex.BaseOffset + ItemIndex];</span><br><span class="line">#endif // VF_GPU_SCENE_TEXTURE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    到这里还剩最后一个问题，instance的数据是如何传入到gpu的，答案就在每帧的调用的UpdateGPUScene和UploadDynamicPrimitiveShaderDataForView，我们截取UpdateGPUSceneInternal中的主要实现来看下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NumPrimitiveDataUploads &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> int32 MaxPrimitivesUploads = <span class="built_in">GetMaxPrimitivesUpdate</span>(NumPrimitiveDataUploads, FPrimitiveSceneShaderData::PrimitiveDataStrideInFloat4s);</span><br><span class="line">    <span class="keyword">for</span> (int32 PrimitiveOffset = <span class="number">0</span>; PrimitiveOffset &lt; NumPrimitiveDataUploads; PrimitiveOffset += MaxPrimitivesUploads)</span><br><span class="line">    &#123;</span><br><span class="line">       Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">Init</span>(MaxPrimitivesUploads, <span class="built_in">sizeof</span>(FPrimitiveSceneShaderData::Data), <span class="literal">true</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;PrimitiveUploadBuffer&quot;</span>));</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 IndexUpdate = <span class="number">0</span>; (IndexUpdate &lt; MaxPrimitivesUploads) &amp;&amp; ((IndexUpdate + PrimitiveOffset) &lt; NumPrimitiveDataUploads); ++IndexUpdate)</span><br><span class="line">       &#123;</span><br><span class="line">          int32 Index = Scene.GPUScene.PrimitivesToUpdate[IndexUpdate + PrimitiveOffset];</span><br><span class="line">          <span class="comment">// PrimitivesToUpdate may contain a stale out of bounds index, as we don&#x27;t remove update request on primitive removal from scene.</span></span><br><span class="line">          <span class="keyword">if</span> (Index &lt; Scene.PrimitiveSceneProxies.<span class="built_in">Num</span>())</span><br><span class="line">          &#123;</span><br><span class="line">             FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy = Scene.PrimitiveSceneProxies[Index];</span><br><span class="line">             NumLightmapDataUploads += PrimitiveSceneProxy-&gt;<span class="built_in">GetPrimitiveSceneInfo</span>()-&gt;<span class="built_in">GetNumLightmapDataEntries</span>();</span><br><span class="line"><span class="comment">//获取每个proxy的primitive数据</span></span><br><span class="line">             <span class="function">FPrimitiveSceneShaderData <span class="title">PrimitiveSceneData</span><span class="params">(PrimitiveSceneProxy)</span></span>;</span><br><span class="line">             Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">Add</span>(Index, &amp;PrimitiveSceneData.Data[<span class="number">0</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          Scene.GPUScene.PrimitivesMarkedToUpdate[Index] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (bResizedPrimitiveData)</span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::ERWBarrier));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::UAVCompute));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          Scene.GPUScene.PrimitiveUploadBuffer.<span class="built_in">ResourceUploadTo</span>(RHICmdList, *MirrorResourceGPU, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(MirrorResourceGPU-&gt;UAV, ERHIAccess::Unknown, ERHIAccess::SRVMask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    (这里先看primitivedata数据部分，lightmap数据部分也是类似)</p><p>数据流向为PrimitiveSceneProxy-&gt;FPrimitiveSceneShaderData-&gt;GPUScene的成员PrimitiveUploadBuffer，调用ResourceUploadTo，而ResourceUploadTo会通过指定的ComputeShader 把GPUScene.PrimitiveUploadBuffer中的ScatterBuffer和UploadBuffer 里的数据存储到了GPUScene.PrimitiveBuffer。</p><p>UploadDynamicPrimitiveShaderDataForView则是把GpuScene中的数据buffer再次copy给View对应的Buffer：PrimitiveShaderDataBuffer/PrimitiveShaderDataTexture，之前存在了gpuscene中的buffer，为什么还需要copy给view对应的buffer转移一次，我猜是因为UE是根据view来分组渲染的，这样传数据更直观，便于区分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部分UploadDynamicPrimitiveShaderDataForView代码</span></span><br><span class="line"><span class="comment">//resize view buffer大小</span></span><br><span class="line"><span class="keyword">if</span> (ViewPrimitiveSceneNumFloat4s * BytesPerElement != ViewPrimitiveShaderDataResource.NumBytes)</span><br><span class="line">&#123;</span><br><span class="line">    ViewPrimitiveShaderDataResource.<span class="built_in">Release</span>();</span><br><span class="line">    <span class="built_in">ResizeResourceIfNeeded</span>(RHICmdList, ViewPrimitiveShaderDataResource, ViewPrimitiveSceneNumFloat4s * BytesPerElement, <span class="built_in">TEXT</span>(<span class="string">&quot;ViewPrimitiveShaderDataBuffer&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copy scene primitive data into view primitive data</span></span><br><span class="line">&#123;</span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::Unknown, ERHIAccess::UAVCompute));</span><br><span class="line">    <span class="built_in">MemcpyResource</span>(RHICmdList, ViewPrimitiveShaderDataResource, *<span class="built_in">GetMirrorGPU</span>&lt;ResourceType&gt;(Scene), Scene.Primitives.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(FPrimitiveSceneShaderData::Data), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::UAVCompute, ERHIAccess::ERWBarrier));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Append View.DynamicPrimitiveShaderData to the end of the view primitive data resource</span></span><br><span class="line"><span class="keyword">if</span> (NumPrimitiveDataUploads &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    int32 MaxPrimitivesUploads = <span class="built_in">GetMaxPrimitivesUpdate</span>(NumPrimitiveDataUploads, FPrimitiveSceneShaderData::PrimitiveDataStrideInFloat4s);</span><br><span class="line">    <span class="keyword">for</span> (int32 PrimitiveOffset = <span class="number">0</span>; PrimitiveOffset &lt; NumPrimitiveDataUploads; PrimitiveOffset += MaxPrimitivesUploads)</span><br><span class="line">    &#123;</span><br><span class="line">       Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">Init</span>( MaxPrimitivesUploads, <span class="built_in">sizeof</span>( FPrimitiveSceneShaderData::Data ), <span class="literal">true</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;PrimitiveUploadViewBuffer&quot;</span>) );</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (int32 IndexUpdate = <span class="number">0</span>; (IndexUpdate &lt; MaxPrimitivesUploads) &amp;&amp; ((IndexUpdate + PrimitiveOffset) &lt; NumPrimitiveDataUploads); ++IndexUpdate)</span><br><span class="line">       &#123;</span><br><span class="line">          int32 DynamicUploadIndex = IndexUpdate + PrimitiveOffset;</span><br><span class="line">          <span class="function">FPrimitiveSceneShaderData <span class="title">PrimitiveSceneData</span><span class="params">(View.DynamicPrimitiveShaderData[DynamicUploadIndex])</span></span>;</span><br><span class="line">          <span class="comment">// Place dynamic primitive shader data just after scene primitive data</span></span><br><span class="line">          Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">Add</span>(Scene.Primitives.<span class="built_in">Num</span>() + DynamicUploadIndex, &amp;PrimitiveSceneData.Data[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">          RHICmdList.<span class="built_in">Transition</span>(<span class="built_in">FRHITransitionInfo</span>(ViewPrimitiveShaderDataResource.UAV, ERHIAccess::ERWBarrier, ERHIAccess::ERWBarrier));</span><br><span class="line">          Scene.GPUScene.PrimitiveUploadViewBuffer.<span class="built_in">ResourceUploadTo</span>(RHICmdList, ViewPrimitiveShaderDataResource, <span class="literal">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GPUScene&quot;&gt;&lt;a href=&quot;#GPUScene&quot; class=&quot;headerlink&quot; title=&quot;GPUScene&quot;&gt;&lt;/a&gt;GPUScene&lt;/h1&gt;&lt;p&gt;GPUScene是UE用来实例化渲染的代码手段，想象场景中包含了数十上百个一样的物体，他们的材质，顶点信息都一样，不同的是他们的位置，缩放等不同，那么我们是否可以通过一个drawcall，来渲染这一批看起来是一个模板的物体，DX和OpenGL都提供了对应的API，我们统称为实例化渲染，本章主要是讲UE是怎么封装这些API，实现自动合批的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="图形学" scheme="https://ritchielambda.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>RumtimeVirtualTexture</title>
    <link href="https://ritchielambda.github.io/2024/05/25/VirtualTexture/"/>
    <id>https://ritchielambda.github.io/2024/05/25/VirtualTexture/</id>
    <published>2024-05-25T00:00:00.000Z</published>
    <updated>2025-02-20T14:21:17.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VirtualTexture工作流程"><a href="#VirtualTexture工作流程" class="headerlink" title="VirtualTexture工作流程"></a>VirtualTexture工作流程</h1><p>VirtualTexture是利用时间换空间的技术，核心原理就是通过把Texture划分成相同大小的Page，在渲染时动态加载/卸载对应的Page，而不是对整个贴图进行操作，整个过程需要三个数据结构，VirtualTexture，PageTable，PhysicalTexture。</p><span id="more"></span><p><img src="/2024/05/25/VirtualTexture/virtualtexture.png" alt="virtualtexture"></p><h2 id="数据结构整理"><a href="#数据结构整理" class="headerlink" title="数据结构整理"></a>数据结构整理</h2><h3 id="FVirtualTextureSpace"><a href="#FVirtualTextureSpace" class="headerlink" title="FVirtualTextureSpace"></a>FVirtualTextureSpace</h3><p>​    一个VirtualTexture的空间，可能包含多个AllocatedVT，空间里的多个VT共享一个坐标系，包含一个Allocator成员用来分配VT，采用先大后小的分配原则，即对于小页面，不断产生child页面来匹配直到匹配到合适的。线分配1024×1024的page，接着分配512，最后分配256的直到大小匹配。</p><p><img src="/2024/05/25/VirtualTexture/allocator.png" alt="image-20240604173802513"></p><h3 id="FVirtualTextureProducer"><a href="#FVirtualTextureProducer" class="headerlink" title="FVirtualTextureProducer"></a>FVirtualTextureProducer</h3><p>与RVT Volume一一对应，用来生产VT的page数据，里面包含有IVirtualTexture成员，该成员的RequestPageData和ProducePageData接口用来真正创建后续绘制VT需要的数据。</p><h3 id="FAllocatedVirtualTexture"><a href="#FAllocatedVirtualTexture" class="headerlink" title="FAllocatedVirtualTexture"></a>FAllocatedVirtualTexture</h3><p>被分配的VT数据，与RVT Volume一一对应，可以注意到每个地形都可以指定一个渲染的RVT，而RVTVolume里也有一个RVT，如果一个地形被包含在RVTVolume中，但是指定的VT与Volume的不同，那么也不会被渲染。AllocatedVT可以理解成一个数据中心，包含了RVT Volume中的VT中的数据，包括每个layer对应的producer，以及Producer中对应的PhysicalGroup。</p><p>如果一个RVT在创建时指定了bSinglePhysicalSpace为true，那么所有的layer都会指向一个physicalgroup，否则的话按照layer来区分group，代码参考GetProducerDescription。</p><h3 id="FVirtualTexturePhysicalSpace"><a href="#FVirtualTexturePhysicalSpace" class="headerlink" title="FVirtualTexturePhysicalSpace"></a>FVirtualTexturePhysicalSpace</h3><p>VT的物理地址空间，是AllocatedVT中的UniquePageTableLayers数据中的成员，如上面所说，如果bSinglePhysicalSpace为true，那么AllocatedVT中所有layer都指向一个group，也就是同一个物理空间。</p><p>PhysicalSpace下面还管理了一个FTexturePagePool，用来真正保存PhysicalPage，以及对应的操作。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>VirtualTexture的数据一切都是从场景中放置的Volume，Volume包含VirtualTextureComponent，会向VirtualTextureSystem注册Producer数据，以及申请对应的FAllocatedVirtualTexture。看代码的时候很容易被各种Index和起名相近的数据结构搞混淆。一个Volume对应一个Producer，对应一个FAllocatedVirtualTexture，FAllocatedVirtualTexture是通过VirtualTextureSystem的Allocator分配的，同一个Space下可以分配多个FAllocatedVirtualTexture。</p><h3 id="1-Render产生FeedBack数据"><a href="#1-Render产生FeedBack数据" class="headerlink" title="1. Render产生FeedBack数据"></a>1. Render产生FeedBack数据</h3><p>这一部分的入口在basepasspixelshader最后的FinalizeVirtualTextureFeedback函数。里面实现很简单，就是把对应像素位置填充上需要加载的VT数据，为了控制带宽，这里不是每个像素都会产生加载请求，而是由VIRTUAL_TEXTURE_FEEDBACK_FACTOR决定更新颗粒度，颗粒度越小更新越细，当然性能也越差，颗粒度大会有部分像素没法更新VT的情况。里面填充的加载申请是在TextureLoadVirtualPageTable被填充。</p><h3 id="2-CPU处理FeedBack数据"><a href="#2-CPU处理FeedBack数据" class="headerlink" title="2. CPU处理FeedBack数据"></a>2. CPU处理FeedBack数据</h3><p>GPU端每帧渲染完画面会产生VT的加载请求，CPU端会在FVirtualTextureSystem::Update中做一系列处理。</p><h4 id="2-1-请求数据筛选整理"><a href="#2-1-请求数据筛选整理" class="headerlink" title="2.1 请求数据筛选整理"></a>2.1 请求数据筛选整理</h4><h5 id="2-1-1-合并同类请求"><a href="#2-1-1-合并同类请求" class="headerlink" title="2.1.1 合并同类请求"></a>2.1.1 合并同类请求</h5><p>多个像素可能申请同一个VT Page，我们需要合并这类请求，这一步通过FFeedbackAnalysisTask多线程处理。</p><h5 id="2-1-2-筛选请求数据"><a href="#2-1-2-筛选请求数据" class="headerlink" title="2.1.2 筛选请求数据"></a>2.1.2 筛选请求数据</h5><p>​    这一步UE同样用了多线程GatherRequestsTask来处理，每个线程处理若干Page的请求。</p><ol><li>对每个PageRequest<ol><li>通过PageMap查找物理Page，<ol><li>如果存在更新，更新PagePool的FreeHeap</li><li>如果不存在记录当前Page的Layer到ToLoad</li></ol></li><li>记录步骤1需要加载的LayerPage的Producer和对应的Group。</li><li>对步骤二的Producer和Group进行循环<ol><li>Producer循环</li><li>对Group循环<ol><li>找到最大分辨率对应的Physicalpage，更新存在physicalpage的LRU</li><li>对所有指向当前group的layer进行Mapping更新</li><li>如果当前group的physicalPage的分辨率远低于申请的，先做预取</li><li>对预取的group申请加载（步骤1.3.2.3得到了对应预取的group，但是我们需要对所有没有对应分辨率的group一起预取，保证所有group数据同步），更新VirtualAdress和PhysicalAdress的mapping</li><li>对于步骤2记录的group申请加载，更新Mapping。</li></ol></li></ol></li></ol></li></ol><h5 id="2-1-3-提交请求"><a href="#2-1-3-提交请求" class="headerlink" title="2.1.3 提交请求"></a>2.1.3 提交请求</h5><ol><li>加载请求：<ol><li>找到请求的producer，对每一个group处理（之前的申请加载参数包含了groupIndex），找到group对应的physicalSpace，申请物理地址，更新ProduceTarget数组</li><li>对于没申请 的group，也填充ProduceTarget数据</li><li>调用ProducePageData生成后面的绘制数据。</li></ol></li><li>Mapping请求</li></ol><p>​    注意这里填充ProduceTarget会赋值两个关键数据：Physical渲染到那个Texture，以及PhysicalPage在Texture的位置，不同的Group拥有不同的PhysicalSpace，所以对应的Texture是不一样的。</p><h4 id="2-2-绘制PhysicalTexture"><a href="#2-2-绘制PhysicalTexture" class="headerlink" title="2.2 绘制PhysicalTexture"></a>2.2 绘制PhysicalTexture</h4><p><img src="/2024/05/25/VirtualTexture/DrawMesh.png" alt="image-20240528211507163"></p><p>这一步的入口还是在SubmitRequests中，对上一步生成的IVirtualTextureFinalizer::Finalize进行绘制，最终生成共用同一个TextureRHI的Page批次信息，调用RenderPages进行同批次绘制，RenderPage则是对单个Page进行绘制，步骤如下：</p><ol><li>设置单个Page需要的View信息，Camera位置。</li><li>调用DrawMeshs绘制当前场景中RuntimeVirtualTextureMask符合的物体。</li><li>调用CompressPass来压缩第二步的RT</li><li>将压缩后的RT合并成更少的RT，以底色、法线、粗糙度、高光度为例，读取3张Texture，Packed并写入到2个RT中。</li><li>将合并后的RT放到PhysicalTexture的对应物理位置上去</li></ol><p>设置View信息时，会根据当前page的UV中心来设置相机位置，确保只渲染当前page</p><p>DrawMeshs时用来筛选物体的RuntimeVirtualTextureMask是在UpdateRuntimeVirtualTextureFlags中更新的，与FRuntimeVirtualTextureSceneProxy一一对应，考虑到一共只有7位预留，也就是说场景中最多存在7个RVTVolume（看代码注释有说会扩展，当超出7位后，会舍弃Mask方法去遍历图元的virtualtexture）</p><p>第五步Copy到PhysicalTexture时，Page在Physical中的位置信息是在2.1.3提交请求中填充ProduceTarget.pPageLocation赋值的，pPageLocation代表的是当前page在physicaltexture中的位置，比如当前physicaltexture中包含8×8个page，pPageLocation为（1，1）</p><h4 id="2-3-更新PageTable"><a href="#2-3-更新PageTable" class="headerlink" title="2.3 更新PageTable"></a>2.3 更新PageTable</h4><p>这一步的入口在FVirtualTextureSpace::ApplyUpdates中，把上面申请加载的physicaltexture更新到对应的PageTable中，数据来源是FVirtualTextureSystem::SubmitRequests中的MappingRequest。这一步主要做了两件事</p><ol><li>更新pagetable上的四叉树子节点</li><li>把pagetableCPU端的buffer渲染到GPU端的RT</li></ol><p>更新部分：PageMap是Mip组成的，MipMap本身可以用四叉树结构来表示，这里用了莫顿码来帮助搜索四叉树，可以快速找到当前Mip的子tile。</p><p>渲染部分：入口是在TPageTableUpdateVS，这里用的Instance多实例渲染，每个实例绘制8个quad，在VS中根据InstanceID和VextexID来取得cpu端对应传入的buffer数据，写到Color里。</p><h3 id="3-GPU端采样VirtualTexture"><a href="#3-GPU端采样VirtualTexture" class="headerlink" title="3. GPU端采样VirtualTexture"></a>3. GPU端采样VirtualTexture</h3><p>通过前面几步，我们得到了：混合了各个Mip的PhysicalTexture合集，以及映射vaddress和paddress的pagetable，接下来看如何使用这两个数据：</p><p>采样的代码通常在materialtemplete中被填充，主要有两个shader函数TextureLoadVirtualPageTable，TextureVirtualSample。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VTPageTableResult Local1 = TextureLoadVirtualPageTable( Material_VirtualTexturePageTable0_0 , VTPageTableUniform_Unpack(Material_VTPackedPageTableUniform[0*2], Material_VTPackedPageTableUniform[0*2+1]), VirtualTextureWorldToUV(GetWorldPosition(Parameters), Material_VectorExpressions[3].rgb, Material_VectorExpressions[2].rgb, Material_VectorExpressions[1].rgb),  0u ,  0u , View_MaterialTextureMipBias, Parameters.SvPosition.xy, 0U +  0 , Parameters.VirtualTextureFeedback);</span><br><span class="line">float4  Local2 = TextureVirtualSample(Material_VirtualTexturePhysical_0, GetMaterialSharedSampler(Material_VirtualTexturePhysical_0Sampler, View_SharedBilinearAnisoClampedSampler), Local1, 0, VTUniform_Unpack(Material_VTPackedUniform[0]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TextureLoadVirtualPageTable负责生成VTPageTableResult结构，TextureVirtualSample负责用VTPageTableResult真正执行Physical采样。</p><h4 id="3-1-TextureLoadVirtualPageTable"><a href="#3-1-TextureLoadVirtualPageTable" class="headerlink" title="3.1 TextureLoadVirtualPageTable"></a>3.1 TextureLoadVirtualPageTable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VTPageTableResult TextureLoadVirtualPageTable(Texture2D&lt;uint4&gt; PageTable0, Texture2D&lt;uint4&gt; PageTable1,</span><br><span class="line">    float2 UV, float MipBias,</span><br><span class="line">    float2 SvPositionXY,</span><br><span class="line">    VTPageTableUniform PageTableUniform,</span><br><span class="line">    uint AddressU, uint AddressV)</span><br><span class="line">&#123;</span><br><span class="line">    VTPageTableResult Result = (VTPageTableResult)0.0f;</span><br><span class="line">    const float2 ScaledUV = UV * PageTableUniform.UVScale;</span><br><span class="line">    uint vLevel = 0u;</span><br><span class="line">#if PIXELSHADER</span><br><span class="line">    vLevel = TextureComputeVirtualMipLevel(Result, ddx(ScaledUV), ddy(ScaledUV), MipBias, SvPositionXY, PageTableUniform);</span><br><span class="line">#endif // PIXELSHADER</span><br><span class="line">    TextureLoadVirtualPageTableInternal(Result, PageTable0, PageTable1, ScaledUV, vLevel, PageTableUniform, AddressU, AddressV);</span><br><span class="line">    return Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这一步通过RVT的UV坐标，计算得到对应pagetable的坐标。RVT的UV坐标指的是当前像素在runtimevirtualtexturevolume内的坐标</p><p><img src="/2024/05/25/VirtualTexture/RVTUV.png" alt="image-20240603163649497"></p><p>以上图为例，黄色线框为场景 中的RVTVolume，里面包含两个带有RVT的地形块，RVT的坐标就是根据世界坐标换算到以RVTVolume的原点，XY轴为坐标轴的坐标系。代码参考如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float2 VirtualTextureWorldToUV(in float3 WorldPos, in float3 Origin, in float3 U, in float3 V)</span><br><span class="line">&#123;</span><br><span class="line">    float3 P = WorldPos - Origin;</span><br><span class="line">    return saturate(float2(dot(P, U), dot(P, V)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着通过TextureComputeVirtualMipLevel得到需要采样的MipLevel，这里额外加了一个噪声扰动以及通过UV的导数来计算MipLevel，通常dUVdx越大，对应的Mip越小（越模糊）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int TextureComputeVirtualMipLevel(</span><br><span class="line">    in out VTPageTableResult OutResult,</span><br><span class="line">    float2 dUVdx, float2 dUVdy, float MipBias,</span><br><span class="line">    float2 SvPositionXY,</span><br><span class="line">    VTPageTableUniform PageTableUniform)</span><br><span class="line">&#123;</span><br><span class="line">    OutResult.dUVdx = dUVdx * PageTableUniform.SizeInPages;</span><br><span class="line">    OutResult.dUVdy = dUVdy * PageTableUniform.SizeInPages;</span><br><span class="line"></span><br><span class="line">    const float Noise = InterleavedGradientNoise(SvPositionXY, View.StateFrameIndexMod8);</span><br><span class="line">    const float ComputedLevel = MipLevelAniso2D(OutResult.dUVdx, OutResult.dUVdy, PageTableUniform.MaxAnisoLog2) + MipBias + Noise * 0.5f - 0.25f;</span><br><span class="line"></span><br><span class="line">    return (int)floor(ComputedLevel) + int(PageTableUniform.vPageTableMipBias);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了PageTable需要求值的Level，接下来通过TextureLoadVirtualPageTableInternal取得对应值，这一步有两个作用，一是填充PageTableValue方便后面采样，二是生成Feedbackrequest，给CPU加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void TextureLoadVirtualPageTableInternal(</span><br><span class="line">    in out VTPageTableResult OutResult,</span><br><span class="line">    Texture2D&lt;uint4&gt; PageTable0,</span><br><span class="line">    VTPageTableUniform PageTableUniform,</span><br><span class="line">    float2 UV, int vLevel)</span><br><span class="line">&#123;</span><br><span class="line">    //这里的sizeinpage 推测应该是page的个数，而不是page的大小</span><br><span class="line">    //输入UV 是0.6 Page个数是8</span><br><span class="line">    //Outresult.uv 就是4.8 表示在第四个page中 page内坐标是0.8</span><br><span class="line">    OutResult.UV = UV * PageTableUniform.SizeInPages;</span><br><span class="line"></span><br><span class="line">    const uint vLevelClamped = clamp(vLevel, 0, int(PageTableUniform.MaxLevel));</span><br><span class="line">    const uint vPageX = (uint(OutResult.UV.x) + PageTableUniform.XOffsetInPages) &gt;&gt; vLevelClamped;</span><br><span class="line">    const uint vPageY = (uint(OutResult.UV.y) + PageTableUniform.YOffsetInPages) &gt;&gt; vLevelClamped;</span><br><span class="line">    //根据UV 坐标拿到pagetable的 值</span><br><span class="line">    OutResult.PageTableValue[0] = PageTable0.Load(int3(vPageX, vPageY, vLevelClamped));</span><br><span class="line">    OutResult.PageTableValue[1] = uint4(0u, 0u, 0u, 0u);</span><br><span class="line"></span><br><span class="line">    // PageTableID packed in upper 4 bits of &#x27;PackedPageTableUniform&#x27;, which is the bit position we want it in for PackedRequest as well, just need to mask off extra bits</span><br><span class="line">    OutResult.PackedRequest = PageTableUniform.ShiftedPageTableID;</span><br><span class="line">    OutResult.PackedRequest |= vPageX;</span><br><span class="line">    OutResult.PackedRequest |= vPageY &lt;&lt; 12;</span><br><span class="line"></span><br><span class="line">    // Feedback always encodes vLevel+1, and subtracts 1 on the CPU side.</span><br><span class="line">    // This allows the CPU code to know when we requested a negative vLevel which indicates that we don&#x27;t have sufficient virtual texture resolution.</span><br><span class="line">    const uint vLevelPlusOneClamped = clamp(vLevel + 1, 0, int(PageTableUniform.MaxLevel + 1));</span><br><span class="line">    OutResult.PackedRequest |= vLevelPlusOneClamped &lt;&lt; 24;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-TextureVirtualSample"><a href="#3-2-TextureVirtualSample" class="headerlink" title="3.2 TextureVirtualSample"></a>3.2 TextureVirtualSample</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaterialFloat4 TextureVirtualSample(</span><br><span class="line">    Texture2D Physical, SamplerState PhysicalSampler,</span><br><span class="line">    VTPageTableResult PageTableResult, uint LayerIndex,</span><br><span class="line">    VTUniform Uniform)</span><br><span class="line">&#123;</span><br><span class="line">    const float2 pUV = VTComputePhysicalUVs(PageTableResult, LayerIndex, Uniform);</span><br><span class="line">    return Physical.SampleGrad(PhysicalSampler, pUV, PageTableResult.dUVdx, PageTableResult.dUVdy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步根据上面得到的page坐标，以及UV坐标取得PhysicalTexture的真正坐标然后采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">float2 VTComputePhysicalUVs(in out VTPageTableResult PageTableResult, uint LayerIndex, VTUniform Uniform)</span><br><span class="line">&#123;</span><br><span class="line">    const uint PackedPageTableValue = PageTableResult.PageTableValue[LayerIndex / 4u][LayerIndex &amp; 3u];</span><br><span class="line"></span><br><span class="line">    // See packing in PageTableUpdate.usf</span><br><span class="line">    const uint vLevel = PackedPageTableValue &amp; 0xf;</span><br><span class="line">    const float UVScale = 1.0f / (float)(1 &lt;&lt; vLevel);</span><br><span class="line">    const float pPageX = (float)((PackedPageTableValue &gt;&gt; 4) &amp; ((1 &lt;&lt; Uniform.PageCoordinateBitCount) - 1));</span><br><span class="line">    const float pPageY = (float)(PackedPageTableValue &gt;&gt; (4 + Uniform.PageCoordinateBitCount));</span><br><span class="line">    //这里取小数部分得到page内的UV坐标</span><br><span class="line">    const float2 vPageFrac = frac(PageTableResult.UV * UVScale);</span><br><span class="line">    //这里得到在整个physical texture 上的坐标</span><br><span class="line">    const float2 pUV = float2(pPageX, pPageY) * Uniform.pPageSize + (vPageFrac * Uniform.vPageSize + Uniform.vPageBorderSize);</span><br><span class="line"></span><br><span class="line">    const float ddxyScale = UVScale * Uniform.vPageSize;</span><br><span class="line">    //表示当前miplevel 下 UV坐标+1 对应实际贴图移动的像素数</span><br><span class="line">    PageTableResult.dUVdx *= ddxyScale;</span><br><span class="line">    PageTableResult.dUVdy *= ddxyScale;</span><br><span class="line">    return pUV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;VirtualTexture工作流程&quot;&gt;&lt;a href=&quot;#VirtualTexture工作流程&quot; class=&quot;headerlink&quot; title=&quot;VirtualTexture工作流程&quot;&gt;&lt;/a&gt;VirtualTexture工作流程&lt;/h1&gt;&lt;p&gt;VirtualTexture是利用时间换空间的技术，核心原理就是通过把Texture划分成相同大小的Page，在渲染时动态加载/卸载对应的Page，而不是对整个贴图进行操作，整个过程需要三个数据结构，VirtualTexture，PageTable，PhysicalTexture。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>球谐光照</title>
    <link href="https://ritchielambda.github.io/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/"/>
    <id>https://ritchielambda.github.io/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/</id>
    <published>2024-04-18T19:47:53.000Z</published>
    <updated>2025-02-20T14:21:17.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p>通俗来说，球谐光照是对漫反射光照的一种近似手段，和IBL类似，但是好处如下：</p><pre><code> 1. 只存储球谐系数，需要的存储空间非常小 2. 利用球谐函数的性质：正交性 &amp; 旋转不变性，可以消除/大大减少漫反射过程中对半球面的积分计算，从而实现实时光照计算。</code></pre><span id="more"></span><h1 id="1-球谐函数"><a href="#1-球谐函数" class="headerlink" title="1. 球谐函数"></a>1. 球谐函数</h1><h2 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h2><p>球谐函数是由一组正交基函数组成，类似于傅里叶展开，这一组基函数可以用来拟合各种函数，定义如下：</p><script type="math/tex; mode=display">y_l^m=\begin{cases}    \sqrt{2}Re(Y_l^m) \quad m>0\\    \sqrt{2}Im(Y_l^m) \quad m<0\\    Y_l^0 \quad m=0\\    \end{cases}    =\begin{cases}    \sqrt{2}K_l^mcos m\varphi P_l^m(cos\theta) \quad m>0\\    \sqrt{2}K_l^msin |m|\varphi P_l^{|m|}(cos\theta) \quad m<0\\    K_l^0P_l^0cos(\theta)\\    \end{cases}\tag1</script><script type="math/tex; mode=display">Y_l^m(\theta,\varphi)=K_l^me^{im\varphi}P_l^{|m|}(cos\theta),l\in{N},-l \leq m \leq l \tag2</script><script type="math/tex; mode=display">K_l^m=\sqrt{\frac{(2l+1)(l-|m|)!}{4\pi(l+|m|)!}}\tag3</script><script type="math/tex; mode=display">P_l^m(x)=\frac{(-1)^m(1-x^2)^{\frac{m}{2}}}{2^ll!}\frac{d^{l+m}}{dx^{l+m}}[(x^2-1)^l]\tag4</script><p>其中y的下标<em>l</em>代表球谐函数的阶数，每一阶由2<em>n</em>+1(-m ~ m)个函数组成，其中$K_l^m$被称为归一化常数，$P_l^m$被称为<strong>伴随勒让德多项式</strong>，该方程是拉普拉斯方程的解，在求解时我们一般不直接对方程求解，而是利用它的递推公式，逐级求解，递推公式如下：</p><script type="math/tex; mode=display">\begin{cases}P_m^m(x)=(-1)^m(2m-1)!!(1-x^2)^{\frac{m}{2}}\\p_{m+1}^m=x(2m+1)p_m^m(x)\\(l-m)P_l^m(x)=x(2l-1)p_{l-1}^m-(l+m-1)p_{l-2}^m(x)\end{cases}\tag5</script><h2 id="1-2-函数图形化表示"><a href="#1-2-函数图形化表示" class="headerlink" title="1.2 函数图形化表示"></a>1.2 函数图形化表示</h2><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/球谐1.jpg" alt></p><center>    球谐函数的通用表示之一，红色代表正，蓝色代表负</center><p><img src="/2024/04/18/%E7%90%83%E8%B0%90%E5%85%89%E7%85%A7/球谐2.jpg" alt="球谐2"></p><center>    球谐函数的通用表达之二：用cubemap展开来表达函数，红色代表正，蓝色代表负，绿色代表0，其中函数值被编码进不同的channel</center><h2 id="1-3-球谐函数性质"><a href="#1-3-球谐函数性质" class="headerlink" title="1.3 球谐函数性质"></a>1.3 球谐函数性质</h2><h3 id="1-3-1-正交性"><a href="#1-3-1-正交性" class="headerlink" title="1.3.1 正交性"></a>1.3.1 正交性</h3><p>假设$y_i$，$y_j$为两个球谐函数，其中$i\in{k}$，，$k$为$2l+m$，那么:</p><script type="math/tex; mode=display">\int_S{y_iy_jd(\theta,\varphi)}=0, when\quad{i\neq j}\tag6</script><p>伴随勒让德多项式是具备正交完备性的，为了让球谐函数也具备正交完备性，所以添加了归一化参数，也就是$K_l^m$</p><h3 id="1-3-2-旋转不变性"><a href="#1-3-2-旋转不变性" class="headerlink" title="1.3.2 旋转不变性"></a>1.3.2 旋转不变性</h3><p>通过上面的介绍，我们知道一个指定的函数$f(\theta,\varphi)$可以被一组球谐函数$y(\theta,\varphi)$所表示，当$(\theta,\varphi)$所表示的点旋转一定角度后得到的新的函数$f(R(\theta,\varphi))$,$R$代表旋转函数，我们要求对应新函数的球谐函数，不需要进行重新计算，可以直接通过原函数的球谐函数经过线性变化得到。</p><h1 id="2-光照方程"><a href="#2-光照方程" class="headerlink" title="2. 光照方程"></a>2. 光照方程</h1><p>​    通用的渲染方程如下，其中$f_r$被称为表面传输系数，也就是我们通常提到的$brdf$，一般的$IBL$照明方案中，为了得到漫反射结果，我们需要进行$S$次积分运算，每次运算都需要对平面所在的半球$\Omega$进行积分。</p><script type="math/tex; mode=display">L(p,w_o)=\int_{\Omega}{f_r(p,w_i,w_o)L_i(p,w_i)n\cdot w_i}dw_i\tag7</script><p>对于漫反射来说$f_r=\frac{1}{\pi}$,然后我们把光照部分和$brdf$以及与法线与入射光夹角分别用一个球谐函数$L_k,T_k$来表示，则公式(7)可以表示为：</p><h1 id="UE-漫反射实现"><a href="#UE-漫反射实现" class="headerlink" title="UE 漫反射实现"></a>UE 漫反射实现</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前文&quot;&gt;&lt;a href=&quot;#前文&quot; class=&quot;headerlink&quot; title=&quot;前文&quot;&gt;&lt;/a&gt;前文&lt;/h1&gt;&lt;p&gt;通俗来说，球谐光照是对漫反射光照的一种近似手段，和IBL类似，但是好处如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1. 只存储球谐系数，需要的存储空间非常小
 2. 利用球谐函数的性质：正交性 &amp;amp; 旋转不变性，可以消除/大大减少漫反射过程中对半球面的积分计算，从而实现实时光照计算。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="图形学" scheme="https://ritchielambda.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>UE VertexFactory</title>
    <link href="https://ritchielambda.github.io/2023/11/05/VertexFactory/"/>
    <id>https://ritchielambda.github.io/2023/11/05/VertexFactory/</id>
    <published>2023-11-05T09:09:53.000Z</published>
    <updated>2025-02-20T14:21:17.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UE-VertexFactory"><a href="#UE-VertexFactory" class="headerlink" title="UE VertexFactory"></a>UE VertexFactory</h1><p>​    个人理解：UE 的VertexFactory是一个用来做数据兼容的结构体，在FBX数据与UE的StaticMesh之间做兼容，在CPU的StaticMesh与GPU的VertexShader之间做兼容。</p><span id="more"></span><h2 id="1-在FBX与StaticMesh之间兼容"><a href="#1-在FBX与StaticMesh之间兼容" class="headerlink" title="1.在FBX与StaticMesh之间兼容"></a>1.在FBX与StaticMesh之间兼容</h2><p>在StaticMesh的导入流程中，Mesh的网格数据都被存储在了FStaticMeshRenderData结构体中，并且会依次执行两个成员的InitResources。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FStaticMeshRenderData - All data needed to render a static mesh.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FStaticMeshRenderData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Default constructor. */</span></span><br><span class="line"><span class="function">ENGINE_API <span class="title">FStaticMeshRenderData</span><span class="params">()</span></span>;</span><br><span class="line">ENGINE_API ~<span class="built_in">FStaticMeshRenderData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Per-LOD resources. For compatibility reasons, the FStaticMeshLODResources array are not referenced through TRefCountPtr.</span></span><br><span class="line"><span class="comment"> * The LODResource still has a ref count of at least 1, see FStaticMeshLODResources() constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FStaticMeshLODResourcesArray LODResources;</span><br><span class="line">FStaticMeshVertexFactoriesArray LODVertexFactories;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UStaticMesh::InitResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (RenderData)</span><br><span class="line">    &#123;</span><br><span class="line">        UWorld* World = <span class="built_in">GetWorld</span>();</span><br><span class="line">        RenderData-&gt;<span class="built_in">InitResources</span>(World ? World-&gt;FeatureLevel.<span class="built_in">GetValue</span>() :                          ERHIFeatureLevel::Num, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中FStaticMeshLODResources::InitResources 为每一种顶点属性都申请了对应的GPU资源，如(Position)VertexBuffer，(Tangent)VertexBuffer，并且将代理保存在Cpu端的数据结构中。</p><p>FStaticMeshVertexFactories::InitResources则是将上面申请得到的代理，与VertexFactory中对应的数据结构绑定，填充其数据结构，主要用VerterxFactory存放两类数据：顶点buffer和顶点声明。</p><p>主要接口是FLocalVertexFactory::InitRHI()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FLocalVertexFactory::InitRHI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">SCOPED_LOADTIMER</span>(FLocalVertexFactory_InitRHI);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// We create different streams based on feature level</span></span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">HasValidFeatureLevel</span>());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// VertexFactory needs to be able to support max possible shader platform and feature level</span></span><br><span class="line">   <span class="comment">// in case if we switch feature level at runtime.</span></span><br><span class="line">   <span class="type">const</span> <span class="type">bool</span> bCanUseGPUScene = <span class="built_in">UseGPUScene</span>(GMaxRHIShaderPlatform, GMaxRHIFeatureLevel);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the vertex buffer containing position is not the same vertex buffer containing the rest of the data,</span></span><br><span class="line">   <span class="comment">// then initialize PositionStream and PositionDeclaration.</span></span><br><span class="line">   <span class="keyword">if</span> (Data.PositionComponent.VertexBuffer != Data.TangentBasisComponents[<span class="number">0</span>].VertexBuffer)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">auto</span> AddDeclaration = [<span class="keyword">this</span>, bCanUseGPUScene](EVertexInputStreamType InputStreamType, <span class="type">bool</span> bAddNormal)</span><br><span class="line">      &#123;</span><br><span class="line">         FVertexDeclarationElementList StreamElements;</span><br><span class="line">         <span class="comment">//这里把Data的数据转换成FVertexElement的形式，保存起来，其中保存了顶点的bindingindex,attributeindex，stride，offset这些数据</span></span><br><span class="line">         <span class="comment">//BindingIndex是C++侧的顶点数据的下标，attributeIndex是Shader侧的顶点属性的索引</span></span><br><span class="line">         <span class="comment">//用意就是告诉Shader 第几个数据流是什么属性</span></span><br><span class="line">         StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.PositionComponent, <span class="number">0</span>, InputStreamType));</span><br><span class="line"></span><br><span class="line">         bAddNormal = bAddNormal &amp;&amp; Data.TangentBasisComponents[<span class="number">1</span>].VertexBuffer != <span class="literal">NULL</span>;</span><br><span class="line">         <span class="keyword">if</span> (bAddNormal)</span><br><span class="line">         &#123;</span><br><span class="line">            StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.TangentBasisComponents[<span class="number">1</span>], <span class="number">2</span>, InputStreamType));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="type">const</span> uint8 TypeIndex = <span class="built_in">static_cast</span>&lt;uint8&gt;(InputStreamType);</span><br><span class="line">         PrimitiveIdStreamIndex[TypeIndex] = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// When the VF is used for rendering in normal mesh passes, this vertex buffer and offset will be overridden</span></span><br><span class="line">            StreamElements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">1</span>, InputStreamType));</span><br><span class="line">            PrimitiveIdStreamIndex[TypeIndex] = StreamElements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">InitDeclaration</span>(StreamElements, InputStreamType);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">AddDeclaration</span>(EVertexInputStreamType::PositionOnly, <span class="literal">false</span>);</span><br><span class="line">      <span class="built_in">AddDeclaration</span>(EVertexInputStreamType::PositionAndNormalOnly, <span class="literal">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   FVertexDeclarationElementList Elements;</span><br><span class="line">   <span class="keyword">if</span>(Data.PositionComponent.VertexBuffer != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(Data.PositionComponent,<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">const</span> uint8 Index = <span class="built_in">static_cast</span>&lt;uint8&gt;(EVertexInputStreamType::Default);</span><br><span class="line">      PrimitiveIdStreamIndex[Index] = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">GetType</span>()-&gt;<span class="built_in">SupportsPrimitiveIdStream</span>() &amp;&amp; bCanUseGPUScene)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// When the VF is used for rendering in normal mesh passes, this vertex buffer and offset will be overridden</span></span><br><span class="line">         Elements.<span class="built_in">Add</span>(<span class="built_in">AccessStreamComponent</span>(<span class="built_in">FVertexStreamComponent</span>(&amp;GPrimitiveIdDummy, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(uint32), VET_UInt, EVertexStreamUsage::Instancing), <span class="number">13</span>));</span><br><span class="line">         PrimitiveIdStreamIndex[Index] = Elements.<span class="built_in">Last</span>().StreamIndex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...... </span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(Streams.<span class="built_in">Num</span>() &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">InitDeclaration</span>(Elements);</span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">IsValidRef</span>(<span class="built_in">GetDeclaration</span>()));</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> int32 DefaultBaseVertexIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="type">const</span> int32 DefaultPreSkinBaseVertexIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">RHISupportsManualVertexFetch</span>(GMaxRHIShaderPlatform) || bCanUseGPUScene)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">SCOPED_LOADTIMER</span>(FLocalVertexFactory_InitRHI_CreateLocalVFUniformBuffer);</span><br><span class="line">      UniformBuffer = <span class="built_in">CreateLocalVFUniformBuffer</span>(<span class="keyword">this</span>, Data.LODLightmapDataIndex, <span class="literal">nullptr</span>, DefaultBaseVertexIndex, DefaultPreSkinBaseVertexIndex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">check</span>(<span class="built_in">IsValidRef</span>(<span class="built_in">GetDeclaration</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitRHI主要是用来做顶点声明RHI申请的，顶点缓冲的RHI资源已经在FStaticMeshVertexFactories::InitVertexFactory接口中从StaticMesh中的LOD数据绑定到的VF对应的Component的Buffer下，在InitRHI中调用了InitDeclaration：最终申请了一个Vertex的RHI资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FVertexFactory::InitDeclaration</span><span class="params">(<span class="type">const</span> FVertexDeclarationElementList&amp; Elements, EVertexInputStreamType StreamType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StreamType == EVertexInputStreamType::PositionOnly)</span><br><span class="line">        &#123;</span><br><span class="line">                PositionDeclaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (StreamType == EVertexInputStreamType::PositionAndNormalOnly)</span><br><span class="line">        &#123;</span><br><span class="line">                PositionAndNormalDeclaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// (StreamType == EVertexInputStreamType::Default)</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Create the vertex declaration for rendering the factory normally.</span></span><br><span class="line">                Declaration = PipelineStateCache::<span class="built_in">GetOrCreateVertexDeclaration</span>(Elements);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FRHIVertexDeclaration*        <span class="title">PipelineStateCache::GetOrCreateVertexDeclaration</span><span class="params">(<span class="type">const</span> FVertexDeclarationElementList&amp; Elements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">// Actual locking/contention time should be close to unmeasurable</span></span><br><span class="line">        <span class="function">FScopeLock <span class="title">ScopeLock</span><span class="params">(&amp;GVertexDeclarationLock)</span></span>;</span><br><span class="line">        uint32 Key = FCrc::<span class="built_in">MemCrc_DEPRECATED</span>(Elements.<span class="built_in">GetData</span>(), Elements.<span class="built_in">Num</span>() * <span class="built_in">sizeof</span>(FVertexElement));</span><br><span class="line">        FRHIVertexDeclaration** Found = GVertexDeclarationCache.<span class="built_in">Find</span>(Key);</span><br><span class="line">        <span class="keyword">if</span> (Found)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">return</span> *Found;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FVertexDeclarationRHIRef NewDeclaration = <span class="built_in">RHICreateVertexDeclaration</span>(Elements);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Add an extra reference so we don&#x27;t have TRefCountPtr in the maps</span></span><br><span class="line">        NewDeclaration-&gt;<span class="built_in">AddRef</span>();</span><br><span class="line">        GVertexDeclarationCache.<span class="built_in">Add</span>(Key, NewDeclaration);</span><br><span class="line">        <span class="keyword">return</span> NewDeclaration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-在StaticMesh和shader中兼容"><a href="#2-在StaticMesh和shader中兼容" class="headerlink" title="2.在StaticMesh和shader中兼容"></a>2.在StaticMesh和shader中兼容</h2><p>到这里VF的数据就被填充好了，什么时候会在渲染时被用到呢，首先捋一下VF被引用的链路：VF是被Mesh-&gt;RenderData-&gt;LODVertexFactories 引用的，所以在生成meshbatch的时候会把VF一起传参，那么看下MeshBatch的生成函数：FStaticMeshSceneProxy::GetMeshElement</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FStaticMeshSceneProxy::GetMeshElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        int32 LODIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        int32 BatchIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        int32 SectionIndex, </span></span></span><br><span class="line"><span class="params"><span class="function">        uint8 InDepthPriorityGroup, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> bUseSelectionOutline,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> bAllowPreCulledIndices, </span></span></span><br><span class="line"><span class="params"><span class="function">        FMeshBatch&amp; OutMeshBatch)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//.....</span></span><br><span class="line">        <span class="type">const</span> FVertexFactory* VertexFactory = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// Has the mesh component overridden the vertex color stream for this mesh LOD?</span></span><br><span class="line">        <span class="keyword">if</span> (ProxyLODInfo.OverrideColorVertexBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// Make sure the indices are accessing data within the vertex buffer&#x27;s</span></span><br><span class="line">                <span class="built_in">check</span>(Section.MaxVertexIndex &lt; ProxyLODInfo.OverrideColorVertexBuffer-&gt;<span class="built_in">GetNumVertices</span>())</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use the instanced colors vertex factory.</span></span><br><span class="line">                VertexFactory = &amp;VFs.VertexFactoryOverrideColorVertexBuffer;</span><br><span class="line"></span><br><span class="line">                OutMeshBatchElement.VertexFactoryUserData = ProxyLODInfo.OverrideColorVFUniformBuffer.<span class="built_in">GetReference</span>();</span><br><span class="line">                OutMeshBatchElement.UserData = ProxyLODInfo.OverrideColorVertexBuffer;</span><br><span class="line">                OutMeshBatchElement.bUserDataIsColorVertexBuffer = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                VertexFactory = &amp;VFs.VertexFactory;</span><br><span class="line"></span><br><span class="line">                OutMeshBatchElement.VertexFactoryUserData = VFs.VertexFactory.<span class="built_in">GetUniformBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bWireframe = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Disable adjacency information when the selection outline is enabled, since tessellation won&#x27;t be used.</span></span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> bRequiresAdjacencyInformation = !bUseSelectionOutline &amp;&amp; <span class="built_in">RequiresAdjacencyInformation</span>(MaterialInterface, VertexFactory-&gt;<span class="built_in">GetType</span>(), FeatureLevel);</span><br><span class="line">        <span class="comment">//最终在SetMeshElementGeometrySource 把VF赋值给了MeshBatch</span></span><br><span class="line">        <span class="type">const</span> uint32 NumPrimitives = <span class="built_in">SetMeshElementGeometrySource</span>(LODIndex, SectionIndex, bWireframe, bRequiresAdjacencyInformation, bUseReversedIndices, bAllowPreCulledIndices, VertexFactory, OutMeshBatch);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BuildMeshDrawCommands中把VF的声明赋值给了BoundShaderState</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> PassShadersType, <span class="keyword">typename</span> ShaderElementDataType&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMeshPassProcessor::BuildMeshDrawCommands</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshBatch&amp; RESTRICT MeshBatch,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint64 BatchElementMask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMaterialRenderProxy&amp; RESTRICT MaterialRenderProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMaterial&amp; RESTRICT MaterialResource,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> FMeshPassProcessorRenderState&amp; RESTRICT DrawRenderState,</span></span></span><br><span class="line"><span class="params"><span class="function">    PassShadersType PassShaders,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerFillMode MeshFillMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    ERasterizerCullMode MeshCullMode,</span></span></span><br><span class="line"><span class="params"><span class="function">    FMeshDrawCommandSortKey SortKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    EMeshPassFeatures MeshPassFeatures,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ShaderElementDataType&amp; ShaderElementData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> FVertexFactory* RESTRICT VertexFactory = MeshBatch.VertexFactory;</span><br><span class="line">    <span class="type">const</span> FPrimitiveSceneInfo* RESTRICT PrimitiveSceneInfo = PrimitiveSceneProxy ? PrimitiveSceneProxy-&gt;<span class="built_in">GetPrimitiveSceneInfo</span>() : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    FMeshDrawCommand SharedMeshDrawCommand;</span><br><span class="line"></span><br><span class="line">    SharedMeshDrawCommand.<span class="built_in">SetStencilRef</span>(DrawRenderState.<span class="built_in">GetStencilRef</span>());</span><br><span class="line"></span><br><span class="line">    FGraphicsMinimalPipelineStateInitializer PipelineState;</span><br><span class="line">    PipelineState.PrimitiveType = (EPrimitiveType)MeshBatch.Type;</span><br><span class="line">    PipelineState.ImmutableSamplerState = MaterialRenderProxy.ImmutableSamplerState;</span><br><span class="line"></span><br><span class="line">    EVertexInputStreamType InputStreamType = EVertexInputStreamType::Default;</span><br><span class="line">    <span class="keyword">if</span> ((MeshPassFeatures &amp; EMeshPassFeatures::PositionOnly) != EMeshPassFeatures::Default)             InputStreamType = EVertexInputStreamType::PositionOnly;</span><br><span class="line">    <span class="keyword">if</span> ((MeshPassFeatures &amp; EMeshPassFeatures::PositionAndNormalOnly) != EMeshPassFeatures::Default)   InputStreamType = EVertexInputStreamType::PositionAndNormalOnly;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(VertexFactory &amp;&amp; VertexFactory-&gt;<span class="built_in">IsInitialized</span>());</span><br><span class="line">    FRHIVertexDeclaration* VertexDeclaration = VertexFactory-&gt;<span class="built_in">GetDeclaration</span>(InputStreamType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(!VertexFactory-&gt;<span class="built_in">NeedsDeclaration</span>() || VertexDeclaration);</span><br><span class="line">    <span class="comment">//赋值操作</span></span><br><span class="line">    SharedMeshDrawCommand.<span class="built_in">SetShaders</span>(VertexDeclaration, PassShaders.<span class="built_in">GetUntypedShaders</span>(), PipelineState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在FMeshDrawCommand::SubmitDraw会重新获得MeshDrawCommands的BoundShaderState</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (MeshDrawCommand.CachedPipelineId.GetId() != StateCache.PipelineId)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FGraphicsPipelineStateInitializer GraphicsPSOInit = MeshPipelineState.AsGraphicsPipelineStateInitializer();</span><br><span class="line">    RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit);</span><br><span class="line">    SetGraphicsPipelineState(RHICmdList<span class="punctuation">,</span> GraphicsPSOInit);</span><br><span class="line">    StateCache.SetPipelineState(MeshDrawCommand.CachedPipelineId.GetId());</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在SetGraphicsPipelineState中会把BoundShaderState转换成对应平台RHI的子类，以OpenGL举例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">virtual void RHISetGraphicsPipelineState(FRHIGraphicsPipelineState* GraphicsState<span class="punctuation">,</span> bool bApplyAdditionalState) final override</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FRHIGraphicsPipelineStateFallBack* FallbackGraphicsState = static_cast&lt;FRHIGraphicsPipelineStateFallBack*&gt;(GraphicsState);</span><br><span class="line"></span><br><span class="line">    auto&amp; PsoInit = FallbackGraphicsState-&gt;Initializer;</span><br><span class="line"></span><br><span class="line">    RHISetBoundShaderState(</span><br><span class="line">       RHICreateBoundShaderState_internal(</span><br><span class="line">          PsoInit.BoundShaderState.VertexDeclarationRHI<span class="punctuation">,</span></span><br><span class="line">          PsoInit.BoundShaderState.VertexShaderRHI<span class="punctuation">,</span></span><br><span class="line">          TESSELLATION_SHADER(PsoInit.BoundShaderState.HullShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          TESSELLATION_SHADER(PsoInit.BoundShaderState.DomainShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          PsoInit.BoundShaderState.PixelShaderRHI<span class="punctuation">,</span></span><br><span class="line">          GEOMETRY_SHADER(PsoInit.BoundShaderState.GeometryShaderRHI)<span class="punctuation">,</span></span><br><span class="line">          PsoInit.bFromPSOFileCache</span><br><span class="line">       ).GetReference()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FOpenGLDynamicRHI::RHIDrawPrimitive</span><span class="params">(uint32 BaseVertexIndex,uint32 NumPrimitives,uint32 NumInstances)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SCOPE_CYCLE_COUNTER_DETAILED</span>(STAT_OpenGLDrawPrimitiveTime);</span><br><span class="line">    <span class="built_in">VERIFY_GL_SCOPE</span>();</span><br><span class="line">    <span class="built_in">RHI_DRAW_CALL_STATS</span>(PrimitiveType,NumPrimitives*NumInstances);</span><br><span class="line"></span><br><span class="line">    FOpenGLContextState&amp; ContextState = <span class="built_in">GetContextStateForCurrentContext</span>();</span><br><span class="line">    <span class="built_in">BindPendingFramebuffer</span>(ContextState);</span><br><span class="line">    <span class="built_in">SetPendingBlendStateForActiveRenderTargets</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateViewportInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateScissorRectInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateRasterizerStateInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">UpdateDepthStencilStateInOpenGLContext</span>(ContextState);</span><br><span class="line">    <span class="built_in">BindPendingShaderState</span>(ContextState);</span><br><span class="line">    <span class="built_in">CommitGraphicsResourceTables</span>();</span><br><span class="line">    <span class="built_in">SetupTexturesForDraw</span>(ContextState);</span><br><span class="line">    <span class="built_in">SetupUAVsForDraw</span>(ContextState);</span><br><span class="line">    <span class="built_in">CommitNonComputeShaderConstants</span>();</span><br><span class="line">    <span class="built_in">CachedBindElementArrayBuffer</span>(ContextState,<span class="number">0</span>);</span><br><span class="line">    uint32 VertexCount = <span class="built_in">GetVertexCountForPrimitiveCount</span>(NumPrimitives,PrimitiveType);</span><br><span class="line">    <span class="comment">//设置顶点数组</span></span><br><span class="line">    <span class="built_in">SetupVertexArrays</span>(ContextState, BaseVertexIndex, PendingState.Streams, NUM_OPENGL_VERTEX_STREAMS, VertexCount);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>UE 在最后提交渲染命令DrawIndexPrimitive时，会先设置管线状态，设置顶点数组，这里就会用到我们上面绑定的顶点声明，参见FOpenGLDynamicRHI::SetupVertexArrays()，在这里我们终于得见底层的API接口调用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FOpenGLDynamicRHI::SetupVertexArrays</span></span><br><span class="line">if (bAnyDifferent)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    if (!VertexElement.bShouldConvertToFloat)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribIFormat(AttributeIndex<span class="punctuation">,</span> VertexElement.Size<span class="punctuation">,</span> VertexElement.Type<span class="punctuation">,</span> VertexElement.Offset);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    else</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribFormat(AttributeIndex<span class="punctuation">,</span> VertexElement.Size<span class="punctuation">,</span> VertexElement.Type<span class="punctuation">,</span> VertexElement.bNormalized<span class="punctuation">,</span> VertexElement.Offset);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    Attr.StreamOffset = VertexElement.Offset;</span><br><span class="line">    Attr.Size = VertexElement.Size;</span><br><span class="line">    Attr.Type = VertexElement.Type;</span><br><span class="line">    Attr.bNormalized = VertexElement.bNormalized;</span><br><span class="line">    Attr.bShouldConvertToFloat = VertexElement.bShouldConvertToFloat;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">if (Attr.StreamIndex != StreamIndex)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexAttribBinding(AttributeIndex<span class="punctuation">,</span> VertexElement.StreamIndex);</span><br><span class="line">    Attr.StreamIndex = StreamIndex;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这里用到了两个API接口VertexAttribIFormat和VertexAttribBinding 设置顶点属性和偏移等数据。</p><p>VertexAttribIFormat 用来设置顶点属性，告诉API如何读取数据。</p><p>VertexAttribBinding 用来设置哪个属性在哪个缓冲区对象中，这里不同的缓冲区对象对应不同的streamIndex</p><p>回过头来看顶点工厂在顶点声明的时候，其中数据所处的Streams数组中的Index决定了当前属性的缓冲区索引</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FVertexElement FVertexFactory<span class="punctuation">:</span><span class="punctuation">:</span>AccessStreamComponent(const FVertexStreamComponent&amp; Component<span class="punctuation">,</span> uint8 AttributeIndex)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    FVertexStream VertexStream;</span><br><span class="line">    VertexStream.VertexBuffer = Component.VertexBuffer;</span><br><span class="line">    VertexStream.Stride = Component.Stride;</span><br><span class="line">    VertexStream.Offset = Component.StreamOffset;</span><br><span class="line">    VertexStream.VertexStreamUsage = Component.VertexStreamUsage;</span><br><span class="line"></span><br><span class="line">    return FVertexElement(Streams.AddUnique(VertexStream)<span class="punctuation">,</span>Component.Offset<span class="punctuation">,</span>Component.Type<span class="punctuation">,</span>AttributeIndex<span class="punctuation">,</span>VertexStream.Stride<span class="punctuation">,</span> EnumHasAnyFlags(EVertexStreamUsage<span class="punctuation">:</span><span class="punctuation">:</span>Instancing<span class="punctuation">,</span> VertexStream.VertexStreamUsage));</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>至于顶点缓冲的绑定也同样是在SetUpVertexArray中，调用了BindVertexBuffer</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">for (uint32 StreamIndex = <span class="number">0</span>; StreamIndex &lt; NumStreams &amp;&amp; StreamMask; StreamIndex++)</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    if (StreamMask &amp; <span class="number">0x1</span>)</span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">       FOpenGLStream &amp;CachedStream = ContextState.VertexStreams<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">       FOpenGLStream &amp;Stream = Streams<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">       if (Stream.VertexBuffer)</span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">          uint32 Offset = BaseVertexIndex * Stream.Stride + Stream.Offset;</span><br><span class="line">          bool bAnyDifferent = <span class="comment">//bitwise ors to get rid of the branches</span></span><br><span class="line">             (CachedStream.VertexBuffer != Stream.VertexBuffer) |</span><br><span class="line">             (CachedStream.Stride != Stream.Stride)|</span><br><span class="line">             (CachedStream.Offset != Offset);</span><br><span class="line"></span><br><span class="line">          if (bAnyDifferent)</span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             check(Stream.VertexBuffer-&gt;Resource != <span class="number">0</span>);</span><br><span class="line">             FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>BindVertexBuffer(StreamIndex<span class="punctuation">,</span> Stream.VertexBuffer-&gt;Resource<span class="punctuation">,</span> Offset<span class="punctuation">,</span> Stream.Stride);</span><br><span class="line">             CachedStream.VertexBuffer = Stream.VertexBuffer;</span><br><span class="line">             CachedStream.Offset = Offset;</span><br><span class="line">             CachedStream.Stride = Stream.Stride;</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">          if (UpdateDivisors &amp;&amp; CachedStream.Divisor != Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>)</span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">             FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>VertexBindingDivisor(StreamIndex<span class="punctuation">,</span> Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>);</span><br><span class="line">             CachedStream.Divisor = Divisor<span class="punctuation">[</span>StreamIndex<span class="punctuation">]</span>;</span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">       else</span><br><span class="line">       <span class="punctuation">&#123;</span></span><br><span class="line">          UE_LOG(LogRHI<span class="punctuation">,</span> Error<span class="punctuation">,</span> TEXT(<span class="string">&quot;Stream %d marked as in use, but vertex buffer provided is NULL (Mask = %x)&quot;</span>)<span class="punctuation">,</span> StreamIndex<span class="punctuation">,</span> StreamMask);</span><br><span class="line">          </span><br><span class="line">          FOpenGL<span class="punctuation">:</span><span class="punctuation">:</span>BindVertexBuffer(StreamIndex<span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span>);</span><br><span class="line">          CachedStream.VertexBuffer = nullptr;</span><br><span class="line">          CachedStream.Offset = <span class="number">0</span>;</span><br><span class="line">          CachedStream.Stride = <span class="number">0</span>;</span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    StreamMask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后附上VF和shader中变量生效的调用栈：</p><p>VF的ModifyCompilationEnvironment</p><p><img src="/2023/11/05/VertexFactory/VF_modify.jpg" alt="VF_modify"></p><p>Shader的modifyCompilationEnvironment</p><p><img src="/2023/11/05/VertexFactory/Shader_modify.jpg" alt="Shader_modify"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;UE-VertexFactory&quot;&gt;&lt;a href=&quot;#UE-VertexFactory&quot; class=&quot;headerlink&quot; title=&quot;UE VertexFactory&quot;&gt;&lt;/a&gt;UE VertexFactory&lt;/h1&gt;&lt;p&gt;​    个人理解：UE 的VertexFactory是一个用来做数据兼容的结构体，在FBX数据与UE的StaticMesh之间做兼容，在CPU的StaticMesh与GPU的VertexShader之间做兼容。&lt;/p&gt;</summary>
    
    
    
    
    <category term="UE源码" scheme="https://ritchielambda.github.io/tags/UE%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
